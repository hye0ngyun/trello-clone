"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[691],{5883:function(e,t,o){let n;o.d(t,{FV:function(){return n3},Wh:function(){return n2},Zl:function(){return n6},cn:function(){return n5},nZ:function(){return n8},sJ:function(){return n4}});var r,a,i,l,s=o(2265),u=o(4887),c=o(2601),err_1=function(e){let t=Error(e);if(void 0===t.stack)try{throw t}catch(e){}return t},Recoil_isPromise=function(e){return!!e&&"function"==typeof e.then},Recoil_nullthrows=function(e,t){if(null!=e)return e;throw err_1(null!=t?t:"Got unexpected null or undefined")};function _defineProperty(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}let BaseLoadable=class BaseLoadable{getValue(){throw err_1("BaseLoadable")}toPromise(){throw err_1("BaseLoadable")}valueMaybe(){throw err_1("BaseLoadable")}valueOrThrow(){throw err_1(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw err_1("BaseLoadable")}promiseOrThrow(){throw err_1(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw err_1("BaseLoadable")}errorOrThrow(){throw err_1(`Loadable expected error, but in "${this.state}" state`)}is(e){return e.state===this.state&&e.contents===this.contents}map(e){throw err_1("BaseLoadable")}};let ValueLoadable=class ValueLoadable extends BaseLoadable{constructor(e){super(),_defineProperty(this,"state","hasValue"),_defineProperty(this,"contents",void 0),this.contents=e}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(e){try{let t=e(this.contents);return Recoil_isPromise(t)?loadableWithPromise(t):isLoadable(t)?t:loadableWithValue(t)}catch(t){return Recoil_isPromise(t)?loadableWithPromise(t.next(()=>this.map(e))):loadableWithError(t)}}};let ErrorLoadable=class ErrorLoadable extends BaseLoadable{constructor(e){super(),_defineProperty(this,"state","hasError"),_defineProperty(this,"contents",void 0),this.contents=e}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(e){return this}};let LoadingLoadable=class LoadingLoadable extends BaseLoadable{constructor(e){super(),_defineProperty(this,"state","loading"),_defineProperty(this,"contents",void 0),this.contents=e}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(e){return loadableWithPromise(this.contents.then(t=>{let o=e(t);if(isLoadable(o))switch(o.state){case"hasValue":case"loading":return o.contents;case"hasError":throw o.contents}return o}).catch(t=>{if(Recoil_isPromise(t))return t.then(()=>this.map(e).contents);throw t}))}};function loadableWithValue(e){return Object.freeze(new ValueLoadable(e))}function loadableWithError(e){return Object.freeze(new ErrorLoadable(e))}function loadableWithPromise(e){return Object.freeze(new LoadingLoadable(e))}function loadableLoading(){return Object.freeze(new LoadingLoadable(new Promise(()=>{})))}function loadableAllArray(e){return e.every(e=>"hasValue"===e.state)?loadableWithValue(e.map(e=>e.contents)):e.some(e=>"hasError"===e.state)?loadableWithError(Recoil_nullthrows(e.find(e=>"hasError"===e.state),"Invalid loadable passed to loadableAll").contents):loadableWithPromise(Promise.all(e.map(e=>e.contents)))}function loadableAll(e){let t=Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t]),o=t.map(e=>isLoadable(e)?e:Recoil_isPromise(e)?loadableWithPromise(e):loadableWithValue(e)),n=loadableAllArray(o);return Array.isArray(e)?n:n.map(t=>Object.getOwnPropertyNames(e).reduce((e,o,n)=>({...e,[o]:t[n]}),{}))}function isLoadable(e){return e instanceof BaseLoadable}var d={loadableWithValue,loadableWithError,loadableWithPromise,loadableLoading,loadableAll,isLoadable,RecoilLoadable:{of:e=>Recoil_isPromise(e)?loadableWithPromise(e):isLoadable(e)?e:loadableWithValue(e),error:e=>loadableWithError(e),loading:()=>loadableLoading(),all:loadableAll,isLoadable}},f=Object.freeze({__proto__:null,loadableWithValue:d.loadableWithValue,loadableWithError:d.loadableWithError,loadableWithPromise:d.loadableWithPromise,loadableLoading:d.loadableLoading,loadableAll:d.loadableAll,isLoadable:d.isLoadable,RecoilLoadable:d.RecoilLoadable});let h={RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED:!0,RECOIL_GKS_ENABLED:new Set(["recoil_hamt_2020","recoil_sync_external_store","recoil_suppress_rerender_in_callback","recoil_memory_managament_2020"])};function readProcessEnvBooleanFlag(e,t){var o,n;let r=null===(o=c.env[e])||void 0===o?void 0:null===(n=o.toLowerCase())||void 0===n?void 0:n.trim();if(null!=r&&""!==r){if(!["true","false"].includes(r))throw err_1(`process.env.${e} value must be 'true', 'false', or empty: ${r}`);t("true"===r)}}function readProcessEnvStringArrayFlag(e,t){var o;let n=null===(o=c.env[e])||void 0===o?void 0:o.trim();null!=n&&""!==n&&t(n.split(/\s*,\s*|\s+/))}function Recoil_gkx_OSS(e){return h.RECOIL_GKS_ENABLED.has(e)}void 0!==c&&(null==c?void 0:c.env)!=null&&(readProcessEnvBooleanFlag("RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED",e=>{h.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED=e}),readProcessEnvStringArrayFlag("RECOIL_GKS_ENABLED",e=>{e.forEach(e=>{h.RECOIL_GKS_ENABLED.add(e)})})),Recoil_gkx_OSS.setPass=e=>{h.RECOIL_GKS_ENABLED.add(e)},Recoil_gkx_OSS.setFail=e=>{h.RECOIL_GKS_ENABLED.delete(e)},Recoil_gkx_OSS.clear=()=>{h.RECOIL_GKS_ENABLED.clear()};var p=Recoil_gkx_OSS,recoverableViolation_1=function(e,t,{error:o}={}){return null};let _=null!==(a=s.createMutableSource)&&void 0!==a?a:s.unstable_createMutableSource,y=null!==(i=s.useMutableSource)&&void 0!==i?i:s.unstable_useMutableSource,m=null!==(l=s.useSyncExternalStore)&&void 0!==l?l:s.unstable_useSyncExternalStore,S=!1;function currentRendererSupportsUseSyncExternalStore(){var e;let{ReactCurrentDispatcher:t,ReactCurrentOwner:o}=s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,n=null!==(e=null==t?void 0:t.current)&&void 0!==e?e:o.currentDispatcher,r=null!=n.useSyncExternalStore;return!m||r||S||(S=!0,recoverableViolation_1("A React renderer without React 18+ API support is being used with React 18+.")),r}function reactMode(){return p("recoil_transition_support")?{mode:"TRANSITION_SUPPORT",early:!0,concurrent:!0}:p("recoil_sync_external_store")&&null!=m?{mode:"SYNC_EXTERNAL_STORE",early:!0,concurrent:!1}:p("recoil_mutable_source")&&null!=y&&"undefined"!=typeof window&&!window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE?p("recoil_suppress_rerender_in_callback")?{mode:"MUTABLE_SOURCE",early:!0,concurrent:!0}:{mode:"MUTABLE_SOURCE",early:!1,concurrent:!1}:p("recoil_suppress_rerender_in_callback")?{mode:"LEGACY",early:!0,concurrent:!1}:{mode:"LEGACY",early:!1,concurrent:!1}}var R={createMutableSource:_,useMutableSource:y,useSyncExternalStore:m,currentRendererSupportsUseSyncExternalStore,reactMode,isFastRefreshEnabled:function(){return!1}};let AbstractRecoilValue=class AbstractRecoilValue{constructor(e){_defineProperty(this,"key",void 0),this.key=e}toJSON(){return{key:this.key}}};let RecoilState=class RecoilState extends AbstractRecoilValue{};let RecoilValueReadOnly=class RecoilValueReadOnly extends AbstractRecoilValue{};function isRecoilValue(e){return e instanceof RecoilState||e instanceof RecoilValueReadOnly}var v={AbstractRecoilValue,RecoilState,RecoilValueReadOnly,isRecoilValue},g=Object.freeze({__proto__:null,AbstractRecoilValue:v.AbstractRecoilValue,RecoilState:v.RecoilState,RecoilValueReadOnly:v.RecoilValueReadOnly,isRecoilValue:v.isRecoilValue}),expectationViolation_1=function(e,...t){},Recoil_mapIterable=function(e,t){return function*(){let o=0;for(let n of e)yield t(n,o++)}()};let{isFastRefreshEnabled:b}=R;let DefaultValue=class DefaultValue{};let T=new DefaultValue,A=new Map,w=new Map;function recoilValuesForKeys(e){return Recoil_mapIterable(e,e=>Recoil_nullthrows(w.get(e)))}function checkForDuplicateAtomKey(e){if(A.has(e)){let t=`Duplicate atom key "${e}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`;console.warn(t)}}function registerNode(e){h.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED&&checkForDuplicateAtomKey(e.key),A.set(e.key,e);let t=null==e.set?new g.RecoilValueReadOnly(e.key):new g.RecoilState(e.key);return w.set(e.key,t),t}let NodeMissingError=class NodeMissingError extends Error{};function getNode(e){let t=A.get(e);if(null==t)throw new NodeMissingError(`Missing definition for RecoilValue: "${e}""`);return t}function getNodeMaybe(e){return A.get(e)}let E=new Map;function deleteNodeConfigIfPossible(e){var t,o;if(!p("recoil_memory_managament_2020"))return;let n=A.get(e);null!=n&&null!==(t=n.shouldDeleteConfigOnRelease)&&void 0!==t&&t.call(n)&&(A.delete(e),null===(o=getConfigDeletionHandler(e))||void 0===o||o(),E.delete(e))}function getConfigDeletionHandler(e){return E.get(e)}var N={nodes:A,recoilValues:w,registerNode,getNode,getNodeMaybe,deleteNodeConfigIfPossible,setConfigDeletionHandler:function(e,t){p("recoil_memory_managament_2020")&&(void 0===t?E.delete(e):E.set(e,t))},getConfigDeletionHandler,recoilValuesForKeys,NodeMissingError,DefaultValue,DEFAULT_VALUE:T},L={enqueueExecution:function(e,t){t()}},V=(function(e){var t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},o={},n={},constant=function(e){return function(){return e}},r=o.hash=function(e){var o=void 0===e?"undefined":t(e);if("number"===o)return e;"string"!==o&&(e+="");for(var n=0,r=0,a=e.length;r<a;++r)n=(n<<5)-n+e.charCodeAt(r)|0;return n},hashFragment=function(e,t){return t>>>e&31},toBitmap=function(e){return 1<<e},fromBitmap=function(e,t){var o;return o=e&t-1,o-=o>>1&1431655765,o=(o=(858993459&o)+(o>>2&858993459))+(o>>4)&252645135,o+=o>>8,127&(o+=o>>16)},arrayUpdate=function(e,t,o,n){var r=n;if(!e){var a=n.length;r=Array(a);for(var i=0;i<a;++i)r[i]=n[i]}return r[t]=o,r},arraySpliceOut=function(e,t,o){var n=o.length-1,r=0,a=0,i=o;if(e)r=a=t;else for(i=Array(n);r<t;)i[a++]=o[r++];for(++r;r<=n;)i[a++]=o[r++];return e&&(i.length=n),i},arraySpliceIn=function(e,t,o,n){var r=n.length;if(e){for(var a=r;a>=t;)n[a--]=n[a];return n[t]=o,n}for(var i=0,l=0,s=Array(r+1);i<t;)s[l++]=n[i++];for(s[t]=o;i<r;)s[++l]=n[i++];return s},a={__hamt_isEmpty:!0},isEmptyNode=function(e){return e===a||e&&e.__hamt_isEmpty},Leaf=function(e,t,o,n){return{type:1,edit:e,hash:t,key:o,value:n,_modify:Leaf__modify}},Collision=function(e,t,o){return{type:2,edit:e,hash:t,children:o,_modify:Collision__modify}},IndexedNode=function(e,t,o){return{type:3,edit:e,mask:t,children:o,_modify:IndexedNode__modify}},ArrayNode=function(e,t,o){return{type:4,edit:e,size:t,children:o,_modify:ArrayNode__modify}},expand=function(e,t,o,n,r){for(var a=[],i=n,l=0,s=0;i;++s)1&i&&(a[s]=r[l++]),i>>>=1;return a[t]=o,ArrayNode(e,l+1,a)},pack=function(e,t,o,n){for(var r=Array(t-1),a=0,i=0,l=0,s=n.length;l<s;++l)if(l!==o){var u=n[l];u&&!isEmptyNode(u)&&(r[a++]=u,i|=1<<l)}return IndexedNode(e,i,r)},mergeLeaves=function mergeLeaves(e,t,o,n,r,a){if(o===r)return Collision(e,o,[a,n]);var i=hashFragment(t,o),l=hashFragment(t,r);return IndexedNode(e,toBitmap(i)|toBitmap(l),i===l?[mergeLeaves(e,t+5,o,n,r,a)]:i<l?[n,a]:[a,n])},updateCollisionList=function(e,t,o,r,a,i,l,s){for(var u=a.length,c=0;c<u;++c){var d=a[c];if(o(l,d.key)){var f=d.value,h=i(f);if(h===f)return a;if(h===n)return--s.value,arraySpliceOut(e,c,a);return arrayUpdate(e,c,Leaf(t,r,l,h),a)}}var p=i();return p===n?a:(++s.value,arrayUpdate(e,u,Leaf(t,r,l,p),a))},canEditNode=function(e,t){return e===t.edit},Leaf__modify=function(e,t,o,r,i,l,s){if(t(l,this.key)){var u=r(this.value);return u===this.value?this:u===n?(--s.value,a):canEditNode(e,this)?(this.value=u,this):Leaf(e,i,l,u)}var c=r();return c===n?this:(++s.value,mergeLeaves(e,o,this.hash,this,i,Leaf(e,i,l,c)))},Collision__modify=function(e,t,o,r,a,i,l){if(a===this.hash){var s=updateCollisionList(canEditNode(e,this),e,t,this.hash,this.children,r,i,l);return s===this.children?this:s.length>1?Collision(e,this.hash,s):s[0]}var u=r();return u===n?this:(++l.value,mergeLeaves(e,o,this.hash,this,a,Leaf(e,a,i,u)))},IndexedNode__modify=function(e,t,o,n,r,i,l){var s,u=this.mask,c=this.children,d=hashFragment(o,r),f=toBitmap(d),h=fromBitmap(u,f),p=u&f,_=p?c[h]:a,y=_._modify(e,t,o+5,n,r,i,l);if(_===y)return this;var m=canEditNode(e,this),S=u,R=void 0;if(p&&isEmptyNode(y)){if(!(S&=~f))return a;if(c.length<=2&&((s=c[1^h])===a||1===s.type||2===s.type))return c[1^h];R=arraySpliceOut(m,h,c)}else if(p||isEmptyNode(y))R=arrayUpdate(m,h,y,c);else{if(c.length>=16)return expand(e,d,y,u,c);S|=f,R=arraySpliceIn(m,h,y,c)}return m?(this.mask=S,this.children=R,this):IndexedNode(e,S,R)},ArrayNode__modify=function(e,t,o,n,r,i,l){var s=this.size,u=this.children,c=hashFragment(o,r),d=u[c],f=(d||a)._modify(e,t,o+5,n,r,i,l);if(d===f)return this;var h=canEditNode(e,this),p=void 0;if(isEmptyNode(d)&&!isEmptyNode(f))++s,p=arrayUpdate(h,c,f,u);else if(!isEmptyNode(d)&&isEmptyNode(f)){if(--s<=8)return pack(e,s,c,u);p=arrayUpdate(h,c,a,u)}else p=arrayUpdate(h,c,f,u);return h?(this.size=s,this.children=p,this):ArrayNode(e,s,p)};function Map(e,t,o,n,r){this._editable=e,this._edit=t,this._config=o,this._root=n,this._size=r}a._modify=function(e,t,o,r,i,l,s){var u=r();return u===n?a:(++s.value,Leaf(e,i,l,u))},Map.prototype.setTree=function(e,t){return this._editable?(this._root=e,this._size=t,this):e===this._root?this:new Map(this._editable,this._edit,this._config,e,t)};var i=o.tryGetHash=function(e,t,o,n){for(var r=n._root,a=0,i=n._config.keyEq;;)switch(r.type){case 1:return i(o,r.key)?r.value:e;case 2:if(t===r.hash)for(var l=r.children,s=0,u=l.length;s<u;++s){var c=l[s];if(i(o,c.key))return c.value}return e;case 3:var d=toBitmap(hashFragment(a,t));if(r.mask&d){r=r.children[fromBitmap(r.mask,d)],a+=5;break}return e;case 4:if(r=r.children[hashFragment(a,t)]){a+=5;break}return e;default:return e}};Map.prototype.tryGetHash=function(e,t,o){return i(e,t,o,this)};var l=o.tryGet=function(e,t,o){return i(e,o._config.hash(t),t,o)};Map.prototype.tryGet=function(e,t){return l(e,t,this)};var s=o.getHash=function(e,t,o){return i(void 0,e,t,o)};Map.prototype.getHash=function(e,t){return s(e,t,this)},o.get=function(e,t){return i(void 0,t._config.hash(e),e,t)},Map.prototype.get=function(e,t){return l(t,e,this)};var u=o.has=function(e,t,o){return i(n,e,t,o)!==n};Map.prototype.hasHash=function(e,t){return u(e,t,this)};var c=o.has=function(e,t){return u(t._config.hash(e),e,t)};Map.prototype.has=function(e){return c(e,this)};var defKeyCompare=function(e,t){return e===t};o.make=function(e){return new Map(0,0,{keyEq:e&&e.keyEq||defKeyCompare,hash:e&&e.hash||r},a,0)},o.empty=o.make();var d=o.isEmpty=function(e){return e&&!!isEmptyNode(e._root)};Map.prototype.isEmpty=function(){return d(this)};var f=o.modifyHash=function(e,t,o,n){var r={value:n._size},a=n._root._modify(n._editable?n._edit:NaN,n._config.keyEq,0,e,t,o,r);return n.setTree(a,r.value)};Map.prototype.modifyHash=function(e,t,o){return f(o,e,t,this)};var h=o.modify=function(e,t,o){return f(e,o._config.hash(t),t,o)};Map.prototype.modify=function(e,t){return h(t,e,this)};var p=o.setHash=function(e,t,o,n){return f(constant(o),e,t,n)};Map.prototype.setHash=function(e,t,o){return p(e,t,o,this)};var _=o.set=function(e,t,o){return p(o._config.hash(e),e,t,o)};Map.prototype.set=function(e,t){return _(e,t,this)};var y=constant(n),m=o.removeHash=function(e,t,o){return f(y,e,t,o)};Map.prototype.removeHash=Map.prototype.deleteHash=function(e,t){return m(e,t,this)};var S=o.remove=function(e,t){return m(t._config.hash(e),e,t)};Map.prototype.remove=Map.prototype.delete=function(e){return S(e,this)};var R=o.beginMutation=function(e){return new Map(e._editable+1,e._edit+1,e._config,e._root,e._size)};Map.prototype.beginMutation=function(){return R(this)};var v=o.endMutation=function(e){return e._editable=e._editable&&e._editable-1,e};Map.prototype.endMutation=function(){return v(this)};var g=o.mutate=function(e,t){var o=R(t);return e(o),v(o)};Map.prototype.mutate=function(e){return g(e,this)};var appk=function(e){return e&&lazyVisitChildren(e[0],e[1],e[2],e[3],e[4])},lazyVisitChildren=function(e,t,o,n,r){for(;o<e;){var a=t[o++];if(a&&!isEmptyNode(a))return lazyVisit(a,n,[e,t,o,n,r])}return appk(r)},lazyVisit=function(e,t,o){switch(e.type){case 1:return{value:t(e),rest:o};case 2:case 4:case 3:var n=e.children;return lazyVisitChildren(n.length,n,0,t,o);default:return appk(o)}},b={done:!0};function MapIterator(e){this.v=e}MapIterator.prototype.next=function(){if(!this.v)return b;var e=this.v;return this.v=appk(e.rest),e},MapIterator.prototype[Symbol.iterator]=function(){return this};var visit=function(e,t){return new MapIterator(lazyVisit(e._root,t))},buildPairs=function(e){return[e.key,e.value]},T=o.entries=function(e){return visit(e,buildPairs)};Map.prototype.entries=Map.prototype[Symbol.iterator]=function(){return T(this)};var buildKeys=function(e){return e.key},A=o.keys=function(e){return visit(e,buildKeys)};Map.prototype.keys=function(){return A(this)};var buildValues=function(e){return e.value},w=o.values=Map.prototype.values=function(e){return visit(e,buildValues)};Map.prototype.values=function(){return w(this)};var E=o.fold=function(e,t,o){var n=o._root;if(1===n.type)return e(t,n.value,n.key);for(var r=[n.children],a=void 0;a=r.pop();)for(var i=0,l=a.length;i<l;){var s=a[i++];s&&s.type&&(1===s.type?t=e(t,s.value,s.key):r.push(s.children))}return t};Map.prototype.fold=function(e,t){return E(e,t,this)};var N=o.forEach=function(e,t){return E(function(o,n,r){return e(n,r,t)},null,t)};Map.prototype.forEach=function(e){return N(e,this)};var L=o.count=function(e){return e._size};Map.prototype.count=function(){return L(this)},Object.defineProperty(Map.prototype,"size",{get:Map.prototype.count}),e.exports?e.exports=o:undefined.hamt=o}(r={exports:{}},r.exports),r.exports);let BuiltInMap=class BuiltInMap{constructor(e){_defineProperty(this,"_map",void 0),this._map=new Map(null==e?void 0:e.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(e){return this._map.get(e)}has(e){return this._map.has(e)}set(e,t){return this._map.set(e,t),this}delete(e){return this._map.delete(e),this}clone(){return persistentMap(this)}toMap(){return new Map(this._map)}};let HashArrayMappedTrieMap=class HashArrayMappedTrieMap{constructor(e){if(_defineProperty(this,"_hamt",V.empty.beginMutation()),e instanceof HashArrayMappedTrieMap){let t=e._hamt.endMutation();e._hamt=t.beginMutation(),this._hamt=t.beginMutation()}else if(e)for(let[t,o]of e.entries())this._hamt.set(t,o)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(e){return this._hamt.get(e)}has(e){return this._hamt.has(e)}set(e,t){return this._hamt.set(e,t),this}delete(e){return this._hamt.delete(e),this}clone(){return persistentMap(this)}toMap(){return new Map(this._hamt)}};function persistentMap(e){return p("recoil_hamt_2020")?new HashArrayMappedTrieMap(e):new BuiltInMap(e)}var C=Object.freeze({__proto__:null,persistentMap:{persistentMap}.persistentMap}),Recoil_differenceSets=function(e,...t){let o=new Set;e:for(let n of e){for(let e of t)if(e.has(n))continue e;o.add(n)}return o},Recoil_mapMap=function(e,t){let o=new Map;return e.forEach((e,n)=>{o.set(n,t(e,n))}),o};function mergeDepsIntoGraph(e,t,o,n){let{nodeDeps:r,nodeToNodeSubscriptions:a}=o,i=r.get(e);if(i&&n&&i!==n.nodeDeps.get(e))return;r.set(e,t);let l=null==i?t:Recoil_differenceSets(t,i);for(let t of l){a.has(t)||a.set(t,new Set);let o=Recoil_nullthrows(a.get(t));o.add(e)}if(i){let o=Recoil_differenceSets(i,t);for(let t of o){if(!a.has(t))return;let o=Recoil_nullthrows(a.get(t));o.delete(e),0===o.size&&a.delete(t)}}}var I={cloneGraph:function(e){return{nodeDeps:Recoil_mapMap(e.nodeDeps,e=>new Set(e)),nodeToNodeSubscriptions:Recoil_mapMap(e.nodeToNodeSubscriptions,e=>new Set(e))}},graph:function(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}},saveDepsToStore:function(e,t,o,n){var r,a,i,l,s;let u=o.getState();n===u.currentTree.version||n===(null===(r=u.nextTree)||void 0===r?void 0:r.version)||n===(null===(a=u.previousTree)||void 0===a?void 0:a.version)||recoverableViolation_1("Tried to save dependencies to a discarded tree");let c=o.getGraph(n);if(mergeDepsIntoGraph(e,t,c),n===(null===(i=u.previousTree)||void 0===i?void 0:i.version)){let n=o.getGraph(u.currentTree.version);mergeDepsIntoGraph(e,t,n,c)}if(n===(null===(l=u.previousTree)||void 0===l?void 0:l.version)||n===u.currentTree.version){let n=null===(s=u.nextTree)||void 0===s?void 0:s.version;if(void 0!==n){let r=o.getGraph(n);mergeDepsIntoGraph(e,t,r,c)}}}};let k=0,P=0,M=0;var U={getNextTreeStateVersion:()=>k++,getNextStoreID:()=>P++,getNextComponentID:()=>M++};let{persistentMap:O}=C,{graph:D}=I,{getNextTreeStateVersion:B}=U;function makeEmptyTreeState(){let e=B();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:O(),nonvalidatedAtoms:O()}}function makeEmptyStoreState(){let e=makeEmptyTreeState();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(e.version,D()),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}var x={makeEmptyTreeState,makeEmptyStoreState,getNextTreeStateVersion:B};let RetentionZone=class RetentionZone{};function retentionZone(){return new RetentionZone}var F={RetentionZone,retentionZone},z={setByAddingToSet:function(e,t){let o=new Set(e);return o.add(t),o},setByDeletingFromSet:function(e,t){let o=new Set(e);return o.delete(t),o},mapBySettingInMap:function(e,t,o){let n=new Map(e);return n.set(t,o),n},mapByUpdatingInMap:function(e,t,o){let n=new Map(e);return n.set(t,o(n.get(t))),n},mapByDeletingFromMap:function(e,t){let o=new Map(e);return o.delete(t),o},mapByDeletingMultipleFromMap:function(e,t){let o=new Map(e);return t.forEach(e=>o.delete(e)),o}},Recoil_filterIterable=function*(e,t){let o=0;for(let n of e)t(n,o++)&&(yield n)},Recoil_lazyProxy=function(e,t){let o=new Proxy(e,{get:(e,o)=>(!(o in e)&&o in t&&(e[o]=t[o]()),e[o]),ownKeys:e=>Object.keys(e)});return o};let{getNode:W,getNodeMaybe:G,recoilValuesForKeys:$}=N,{RetentionZone:H}=F,{setByAddingToSet:K}=z,q=Object.freeze(new Set);let ReadOnlyRecoilValueError=class ReadOnlyRecoilValueError extends Error{};function initializeRetentionForNode(e,t,o){if(!p("recoil_memory_managament_2020"))return()=>void 0;let{nodesRetainedByZone:n}=e.getState().retention;function addToZone(e){let o=n.get(e);o||n.set(e,o=new Set),o.add(t)}if(o instanceof H)addToZone(o);else if(Array.isArray(o))for(let e of o)addToZone(e);return()=>{if(!p("recoil_memory_managament_2020"))return;let{retention:n}=e.getState();function deleteFromZone(e){let o=n.nodesRetainedByZone.get(e);null==o||o.delete(t),o&&0===o.size&&n.nodesRetainedByZone.delete(e)}if(o instanceof H)deleteFromZone(o);else if(Array.isArray(o))for(let e of o)deleteFromZone(e)}}function initializeNodeIfNewToStore(e,t,o,n){let r=e.getState();if(r.nodeCleanupFunctions.has(o))return;let a=W(o),i=initializeRetentionForNode(e,o,a.retainedBy),l=a.init(e,t,n);r.nodeCleanupFunctions.set(o,()=>{l(),i()})}function peekNodeLoadable(e,t,o){return W(o).peek(e,t)}function peekNodeInfo(e,t,o){let n=e.getState(),r=e.getGraph(t.version),a=W(o).nodeType;return Recoil_lazyProxy({type:a},{loadable:()=>peekNodeLoadable(e,t,o),isActive:()=>n.knownAtoms.has(o)||n.knownSelectors.has(o),isSet:()=>"selector"!==a&&t.atomValues.has(o),isModified:()=>t.dirtyAtoms.has(o),deps:()=>{var e;return $(null!==(e=r.nodeDeps.get(o))&&void 0!==e?e:[])},subscribers:()=>{var r,a;return{nodes:$(Recoil_filterIterable(getDownstreamNodes(e,t,new Set([o])),e=>e!==o)),components:Recoil_mapIterable(null!==(r=null===(a=n.nodeToComponentSubscriptions.get(o))||void 0===a?void 0:a.values())&&void 0!==r?r:[],([e])=>({name:e}))}}})}function getDownstreamNodes(e,t,o){let n=new Set,r=Array.from(o),a=e.getGraph(t.version);for(let e=r.pop();e;e=r.pop()){var i;n.add(e);let t=null!==(i=a.nodeToNodeSubscriptions.get(e))&&void 0!==i?i:q;for(let e of t)n.has(e)||r.push(e)}return n}var j={getNodeLoadable:function(e,t,o){return initializeNodeIfNewToStore(e,t,o,"get"),W(o).get(e,t)},peekNodeLoadable,setNodeValue:function(e,t,o,n){let r=W(o);if(null==r.set)throw new ReadOnlyRecoilValueError(`Attempt to set read-only RecoilValue: ${o}`);let a=r.set;return initializeNodeIfNewToStore(e,t,o,"set"),a(e,t,n)},initializeNode:function(e,t,o){initializeNodeIfNewToStore(e,e.getState().currentTree,t,o)},cleanUpNode:function(e,t){var o;let n=e.getState();null===(o=n.nodeCleanupFunctions.get(t))||void 0===o||o(),n.nodeCleanupFunctions.delete(t)},setUnvalidatedAtomValue_DEPRECATED:function(e,t,o){var n;let r=G(t);return null==r||null===(n=r.invalidate)||void 0===n||n.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,o),dirtyAtoms:K(e.dirtyAtoms,t)}},peekNodeInfo,getDownstreamNodes};let Z=null;var Y={setInvalidateMemoizedSnapshot:function(e){Z=e},invalidateMemoizedSnapshot:function(){var e;null===(e=Z)||void 0===e||e()}};let{getDownstreamNodes:J,getNodeLoadable:X,setNodeValue:Q}=j,{getNextComponentID:ee}=U,{getNode:et,getNodeMaybe:eo}=N,{DefaultValue:en}=N,{reactMode:er}=R,{AbstractRecoilValue:ea,RecoilState:ei,RecoilValueReadOnly:el,isRecoilValue:es}=g,{invalidateMemoizedSnapshot:eu}=Y;function getRecoilValueAsLoadable(e,{key:t},o=e.getState().currentTree){var n,r;let a=e.getState();o.version===a.currentTree.version||o.version===(null===(n=a.nextTree)||void 0===n?void 0:n.version)||o.version===(null===(r=a.previousTree)||void 0===r?void 0:r.version)||recoverableViolation_1("Tried to read from a discarded tree");let i=X(e,o,t);return"loading"===i.state&&i.contents.catch(()=>{}),i}function applyAtomValueWrites(e,t){let o=e.clone();return t.forEach((e,t)=>{"hasValue"===e.state&&e.contents instanceof en?o.delete(t):o.set(t,e)}),o}function valueFromValueOrUpdater(e,t,{key:o},n){if("function"!=typeof n)return n;{let r=X(e,t,o);if("loading"===r.state){let e=`Tried to set atom or selector "${o}" using an updater function while the current state is pending, this is not currently supported.`;throw recoverableViolation_1(e),err_1(e)}if("hasError"===r.state)throw r.contents;return n(r.contents)}}function applyAction(e,t,o){if("set"===o.type){let{recoilValue:n,valueOrUpdater:r}=o,a=valueFromValueOrUpdater(e,t,n,r),i=Q(e,t,n.key,a);for(let[e,o]of i.entries())writeLoadableToTreeState(t,e,o)}else if("setLoadable"===o.type){let{recoilValue:{key:e},loadable:n}=o;writeLoadableToTreeState(t,e,n)}else if("markModified"===o.type){let{recoilValue:{key:e}}=o;t.dirtyAtoms.add(e)}else if("setUnvalidated"===o.type){var n;let{recoilValue:{key:e},unvalidatedValue:r}=o,a=eo(e);null==a||null===(n=a.invalidate)||void 0===n||n.call(a,t),t.atomValues.delete(e),t.nonvalidatedAtoms.set(e,r),t.dirtyAtoms.add(e)}else recoverableViolation_1(`Unknown action ${o.type}`)}function writeLoadableToTreeState(e,t,o){"hasValue"===o.state&&o.contents instanceof en?e.atomValues.delete(t):e.atomValues.set(t,o),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function applyActionsToStore(e,t){e.replaceState(o=>{let n=copyTreeState(o);for(let o of t)applyAction(e,n,o);return invalidateDownstreams(e,n),eu(),n})}function queueOrPerformStateUpdate(e,t){if(ec.length){let o=ec[ec.length-1],n=o.get(e);n||o.set(e,n=[]),n.push(t)}else applyActionsToStore(e,[t])}let ec=[];function copyTreeState(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function invalidateDownstreams(e,t){let o=J(e,t,t.dirtyAtoms);for(let e of o){var n,r;null===(n=eo(e))||void 0===n||null===(r=n.invalidate)||void 0===r||r.call(n,t)}}function setRecoilValue(e,t,o){queueOrPerformStateUpdate(e,{type:"set",recoilValue:t,valueOrUpdater:o})}function setRecoilValueLoadable(e,t,o){if(o instanceof en)return setRecoilValue(e,t,o);queueOrPerformStateUpdate(e,{type:"setLoadable",recoilValue:t,loadable:o})}var ed={RecoilValueReadOnly:el,AbstractRecoilValue:ea,RecoilState:ei,getRecoilValueAsLoadable,setRecoilValue,setRecoilValueLoadable,markRecoilValueModified:function(e,t){queueOrPerformStateUpdate(e,{type:"markModified",recoilValue:t})},setUnvalidatedRecoilValue:function(e,t,o){queueOrPerformStateUpdate(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:o})},subscribeToRecoilValue:function(e,{key:t},o,n=null){let r=ee(),a=e.getState();a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),Recoil_nullthrows(a.nodeToComponentSubscriptions.get(t)).set(r,[null!=n?n:"<not captured>",o]);let i=er();if(i.early&&("LEGACY"===i.mode||"MUTABLE_SOURCE"===i.mode)){let n=e.getState().nextTree;n&&n.dirtyAtoms.has(t)&&o(n)}return{release:()=>{let o=e.getState(),n=o.nodeToComponentSubscriptions.get(t);if(void 0===n||!n.has(r)){recoverableViolation_1(`Subscription missing at release time for atom ${t}. This is a bug in Recoil.`);return}n.delete(r),0===n.size&&o.nodeToComponentSubscriptions.delete(t)}}},isRecoilValue:es,applyAtomValueWrites,batchStart:function(){let e=new Map;return ec.push(e),()=>{for(let[t,o]of e)applyActionsToStore(t,o);let t=ec.pop();t!==e&&recoverableViolation_1("Incorrect order of batch popping")}},writeLoadableToTreeState,invalidateDownstreams,copyTreeState,refreshRecoilValue:function(e,t){var o;let{currentTree:n}=e.getState(),r=et(t.key);null===(o=r.clearCache)||void 0===o||o.call(r,e,n)}},Recoil_someSet=function(e,t,o){let n=e.entries(),r=n.next();for(;!r.done;){let a=r.value;if(t.call(o,a[1],a[0],e))return!0;r=n.next()}return!1};let{cleanUpNode:ef}=j,{deleteNodeConfigIfPossible:eh,getNode:ep}=N,{RetentionZone:e_}=F,ey=new Set;function releaseRetainablesNowOnCurrentTree(e,t){let o=e.getState(),n=o.currentTree;if(o.nextTree){recoverableViolation_1("releaseNodesNowOnCurrentTree should only be called at the end of a batch");return}let r=new Set;for(let e of t)if(e instanceof e_)for(let t of nodesRetainedByZone(o,e))r.add(t);else r.add(e);let a=findReleasableNodes(e,r);for(let t of a)releaseNode(e,n,t)}function findReleasableNodes(e,t){let o=e.getState(),n=o.currentTree,r=e.getGraph(n.version),a=new Set,i=new Set;return findReleasableNodesInner(t),a;function findReleasableNodesInner(t){var l,s;let u=new Set,c=getDownstreamNodesInTopologicalOrder(e,n,t,a,i);for(let e of c){if("recoilRoot"===ep(e).retainedBy||(null!==(l=o.retention.referenceCounts.get(e))&&void 0!==l?l:0)>0||zonesThatCouldRetainNode(e).some(e=>o.retention.referenceCounts.get(e))){i.add(e);continue}let t=r.nodeToNodeSubscriptions.get(e);if(t&&Recoil_someSet(t,e=>i.has(e))){i.add(e);continue}a.add(e),u.add(e)}let d=new Set;for(let e of u)for(let t of null!==(s=r.nodeDeps.get(e))&&void 0!==s?s:ey)a.has(t)||d.add(t);d.size&&findReleasableNodesInner(d)}}function getDownstreamNodesInTopologicalOrder(e,t,o,n,r){let a=e.getGraph(t.version),i=[],l=new Set;for(;o.size>0;)visit(Recoil_nullthrows(o.values().next().value));return i;function visit(e){if(n.has(e)||r.has(e)){o.delete(e);return}if(l.has(e))return;let t=a.nodeToNodeSubscriptions.get(e);if(t)for(let e of t)visit(e);l.add(e),o.delete(e),i.push(e)}}function releaseNode(e,t,o){var n,r;if(!p("recoil_memory_managament_2020"))return;ef(e,o);let a=e.getState();a.knownAtoms.delete(o),a.knownSelectors.delete(o),a.nodeTransactionSubscriptions.delete(o),a.retention.referenceCounts.delete(o);let i=zonesThatCouldRetainNode(o);for(let e of i)null===(n=a.retention.nodesRetainedByZone.get(e))||void 0===n||n.delete(o);t.atomValues.delete(o),t.dirtyAtoms.delete(o),t.nonvalidatedAtoms.delete(o);let l=a.graphsByVersion.get(t.version);if(l){let e=l.nodeDeps.get(o);if(void 0!==e)for(let t of(l.nodeDeps.delete(o),e))null===(r=l.nodeToNodeSubscriptions.get(t))||void 0===r||r.delete(o);l.nodeToNodeSubscriptions.delete(o)}eh(o)}function nodesRetainedByZone(e,t){var o;return null!==(o=e.retention.nodesRetainedByZone.get(t))&&void 0!==o?o:ey}function zonesThatCouldRetainNode(e){let t=ep(e).retainedBy;return void 0===t||"components"===t||"recoilRoot"===t?[]:t instanceof e_?[t]:t}function scheduleOrPerformPossibleReleaseOfRetainable(e,t){let o=e.getState();o.nextTree?o.retention.retainablesToCheckForRelease.add(t):releaseRetainablesNowOnCurrentTree(e,new Set([t]))}function updateRetainCountToZero(e,t){if(!p("recoil_memory_managament_2020"))return;let o=e.getState().retention.referenceCounts;o.delete(t),scheduleOrPerformPossibleReleaseOfRetainable(e,t)}var em={SUSPENSE_TIMEOUT_MS:12e4,updateRetainCount:function(e,t,o){var n;if(!p("recoil_memory_managament_2020"))return;let r=e.getState().retention.referenceCounts,a=(null!==(n=r.get(t))&&void 0!==n?n:0)+o;0===a?updateRetainCountToZero(e,t):r.set(t,a)},updateRetainCountToZero,releaseScheduledRetainablesNow:function(e){if(!p("recoil_memory_managament_2020"))return;let t=e.getState();releaseRetainablesNowOnCurrentTree(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()},retainedByOptionWithDefault:function(e){return void 0===e?"recoilRoot":e}};let{unstable_batchedUpdates:eS}=u,{unstable_batchedUpdates:eR}={unstable_batchedUpdates:eS},{batchStart:ev}=ed,{unstable_batchedUpdates:eg}={unstable_batchedUpdates:eR},eb=eg||(e=>e());var eT={getBatcher:()=>eb,setBatcher:e=>{eb=e},batchUpdates:e=>{eb(()=>{let batchEnd=()=>void 0;try{batchEnd=ev(),e()}finally{batchEnd()}})}},Recoil_concatIterables=function*(e){for(let t of e)for(let e of t)yield e};let eA="undefined"==typeof Window||"undefined"==typeof window,ew="undefined"!=typeof navigator&&"ReactNative"===navigator.product;var eE={isSSR:eA,isReactNative:ew,isWindow:e=>!eA&&(e===window||e instanceof Window)};function memoizeWithArgsHash(e,t){let o;return(...n)=>{o||(o={});let r=t(...n);return Object.hasOwnProperty.call(o,r)||(o[r]=e(...n)),o[r]}}function memoizeOneWithArgsHash(e,t){let o,n;return(...r)=>{let a=t(...r);return o===a?n:(o=a,n=e(...r))}}function memoizeOneWithArgsHashAndInvalidation(e,t){let o,n;return[(...r)=>{let a=t(...r);return o===a?n:(o=a,n=e(...r))},()=>{o=null}]}let{batchUpdates:eN}=eT,{initializeNode:eL,peekNodeInfo:eV}=j,{graph:eC}=I,{getNextStoreID:eI}=U,{DEFAULT_VALUE:ek,recoilValues:eP,recoilValuesForKeys:eM}=N,{AbstractRecoilValue:eU,getRecoilValueAsLoadable:eO,setRecoilValue:eD,setUnvalidatedRecoilValue:eB}=ed,{updateRetainCount:ex}=em,{setInvalidateMemoizedSnapshot:eF}=Y,{getNextTreeStateVersion:ez,makeEmptyStoreState:eW}=x,{isSSR:eG}=eE,{memoizeOneWithArgsHashAndInvalidation:e$}={memoizeWithArgsHash,memoizeOneWithArgsHash,memoizeOneWithArgsHashAndInvalidation};let Snapshot=class Snapshot{constructor(e,t){for(let o of(_defineProperty(this,"_store",void 0),_defineProperty(this,"_refCount",1),_defineProperty(this,"getLoadable",e=>(this.checkRefCount_INTERNAL(),eO(this._store,e))),_defineProperty(this,"getPromise",e=>(this.checkRefCount_INTERNAL(),this.getLoadable(e).toPromise())),_defineProperty(this,"getNodes_UNSTABLE",e=>{if(this.checkRefCount_INTERNAL(),(null==e?void 0:e.isModified)===!0){if((null==e?void 0:e.isInitialized)===!1)return[];let t=this._store.getState().currentTree;return eM(t.dirtyAtoms)}let t=this._store.getState().knownAtoms,o=this._store.getState().knownSelectors;return(null==e?void 0:e.isInitialized)==null?eP.values():!0===e.isInitialized?eM(Recoil_concatIterables([t,o])):Recoil_filterIterable(eP.values(),({key:e})=>!t.has(e)&&!o.has(e))}),_defineProperty(this,"getInfo_UNSTABLE",({key:e})=>(this.checkRefCount_INTERNAL(),eV(this._store,this._store.getState().currentTree,e))),_defineProperty(this,"map",e=>{this.checkRefCount_INTERNAL();let t=new MutableSnapshot(this,eN);return e(t),t}),_defineProperty(this,"asyncMap",async e=>{this.checkRefCount_INTERNAL();let t=new MutableSnapshot(this,eN);return t.retain(),await e(t),t.autoRelease_INTERNAL(),t}),this._store={storeID:eI(),parentStoreID:t,getState:()=>e,replaceState:t=>{e.currentTree=t(e.currentTree)},getGraph:t=>{let o=e.graphsByVersion;if(o.has(t))return Recoil_nullthrows(o.get(t));let n=eC();return o.set(t,n),n},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw err_1("Cannot subscribe to Snapshots")}},this._store.getState().knownAtoms))eL(this._store,o,"get"),ex(this._store,o,1);this.autoRelease_INTERNAL()}retain(){this._refCount<=0&&recoverableViolation_1("Attempt to retain() Snapshot that was already released."),this._refCount++;let e=!1;return()=>{e||(e=!0,this._release())}}autoRelease_INTERNAL(){eG||window.setTimeout(()=>this._release(),10)}_release(){if(this._refCount--,0===this._refCount){if(this._store.getState().nodeCleanupFunctions.forEach(e=>e()),this._store.getState().nodeCleanupFunctions.clear(),!p("recoil_memory_managament_2020"))return}else this._refCount}isRetained(){return this._refCount>0}checkRefCount_INTERNAL(){p("recoil_memory_managament_2020")&&this._refCount}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}getStoreID(){return this.checkRefCount_INTERNAL(),this._store.storeID}};function cloneStoreState(e,t,o=!1){let n=e.getState(),r=o?ez():t.version;return{currentTree:{version:o?r:t.version,stateID:o?r:t.stateID,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()},commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(n.knownAtoms),knownSelectors:new Set(n.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(r,e.getGraph(t.version)),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map(Recoil_mapIterable(n.nodeCleanupFunctions.entries(),([e])=>[e,()=>{}]))}}function freshSnapshot(e){let t=new Snapshot(eW());return null!=e?t.map(e):t}let[eH,eK]=e$((e,t)=>{var o;let n=e.getState(),r="latest"===t?null!==(o=n.nextTree)&&void 0!==o?o:n.currentTree:Recoil_nullthrows(n.previousTree);return new Snapshot(cloneStoreState(e,r),e.storeID)},(e,t)=>{var o,n;return String(t)+String(e.storeID)+String(null===(o=e.getState().nextTree)||void 0===o?void 0:o.version)+String(e.getState().currentTree.version)+String(null===(n=e.getState().previousTree)||void 0===n?void 0:n.version)});function cloneSnapshot(e,t="latest"){let o=eH(e,t);return o.isRetained()?o:(eK(),eH(e,t))}eF(eK);let MutableSnapshot=class MutableSnapshot extends Snapshot{constructor(e,t){super(cloneStoreState(e.getStore_INTERNAL(),e.getStore_INTERNAL().getState().currentTree,!0),e.getStoreID()),_defineProperty(this,"_batch",void 0),_defineProperty(this,"set",(e,t)=>{this.checkRefCount_INTERNAL();let o=this.getStore_INTERNAL();this._batch(()=>{ex(o,e.key,1),eD(this.getStore_INTERNAL(),e,t)})}),_defineProperty(this,"reset",e=>{this.checkRefCount_INTERNAL();let t=this.getStore_INTERNAL();this._batch(()=>{ex(t,e.key,1),eD(this.getStore_INTERNAL(),e,ek)})}),_defineProperty(this,"setUnvalidatedAtomValues_DEPRECATED",e=>{this.checkRefCount_INTERNAL();let t=this.getStore_INTERNAL();eN(()=>{for(let[o,n]of e.entries())ex(t,o,1),eB(t,new eU(o),n)})}),this._batch=t}};var eq={Snapshot,MutableSnapshot,freshSnapshot,cloneSnapshot},ej=Object.freeze({__proto__:null,Snapshot:eq.Snapshot,MutableSnapshot:eq.MutableSnapshot,freshSnapshot:eq.freshSnapshot,cloneSnapshot:eq.cloneSnapshot}),Recoil_unionSets=function(...e){let t=new Set;for(let o of e)for(let e of o)t.add(e);return t};let{useRef:eZ}=s;var Recoil_useRefInitOnce=function(e){let t=eZ(e);return t.current===e&&"function"==typeof e&&(t.current=e()),t};let{getNextTreeStateVersion:eY,makeEmptyStoreState:eJ}=x,{cleanUpNode:eX,getDownstreamNodes:eQ,initializeNode:e0,setNodeValue:e1,setUnvalidatedAtomValue_DEPRECATED:e2}=j,{graph:e5}=I,{cloneGraph:e8}=I,{getNextStoreID:e4}=U,{createMutableSource:e3,reactMode:e6}=R,{applyAtomValueWrites:e9}=ed,{releaseScheduledRetainablesNow:e7}=em,{freshSnapshot:te}=ej,{useCallback:tt,useContext:to,useEffect:tn,useMemo:tr,useRef:ta,useState:ti}=s;function notInAContext(){throw err_1("This component must be used inside a <RecoilRoot> component.")}let tl=Object.freeze({storeID:e4(),getState:notInAContext,replaceState:notInAContext,getGraph:notInAContext,subscribeToTransactions:notInAContext,addTransactionMetadata:notInAContext}),ts=!1;function startNextTreeIfNeeded(e){if(ts)throw err_1("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");let t=e.getState();if(null===t.nextTree){p("recoil_memory_managament_2020")&&p("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&e7(e);let o=t.currentTree.version,n=eY();t.nextTree={...t.currentTree,version:n,stateID:n,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(n,e8(Recoil_nullthrows(t.graphsByVersion.get(o))))}}let tu=s.createContext({current:tl}),useStoreRef=()=>to(tu),tc=s.createContext(null);function notifyComponents(e,t,o){let n=eQ(e,o,o.dirtyAtoms);for(let e of n){let n=t.nodeToComponentSubscriptions.get(e);if(n)for(let[e,[t,r]]of n)r(o)}}function sendEndOfBatchNotifications(e){let t=e.getState(),o=t.currentTree,n=o.dirtyAtoms;if(n.size){for(let[o,r]of t.nodeTransactionSubscriptions)if(n.has(o))for(let[t,o]of r)o(e);for(let[o,n]of t.transactionSubscriptions)n(e);(!e6().early||t.suspendedComponentResolvers.size>0)&&(notifyComponents(e,t,o),t.suspendedComponentResolvers.forEach(e=>e()),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach(e=>e(o)),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function endBatch(e){let t=e.getState();t.commitDepth++;try{let{nextTree:o}=t;if(null==o)return;t.previousTree=t.currentTree,t.currentTree=o,t.nextTree=null,sendEndOfBatchNotifications(e),null!=t.previousTree?t.graphsByVersion.delete(t.previousTree.version):recoverableViolation_1("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,p("recoil_memory_managament_2020")&&null==o&&e7(e)}finally{t.commitDepth--}}function Batcher({setNotifyBatcherOfChange:e}){let t=useStoreRef(),[,o]=ti([]);return e(()=>o({})),tn(()=>(e(()=>o({})),()=>{e(()=>{})}),[e]),tn(()=>{var e;e=0,(()=>{endBatch(t.current)})()}),null}function initialStoreState_DEPRECATED(e,t){let o=eJ();return t({set:(t,n)=>{let r=o.currentTree,a=e1(e,r,t.key,n),i=new Set(a.keys()),l=r.nonvalidatedAtoms.clone();for(let e of i)l.delete(e);o.currentTree={...r,dirtyAtoms:Recoil_unionSets(r.dirtyAtoms,i),atomValues:e9(r.atomValues,a),nonvalidatedAtoms:l}},setUnvalidatedAtomValues:e=>{e.forEach((e,t)=>{o.currentTree=e2(o.currentTree,t,e)})}}),o}function initialStoreState(e){let t=te(e),o=t.getStore_INTERNAL().getState();return t.retain(),o.nodeCleanupFunctions.forEach(e=>e()),o.nodeCleanupFunctions.clear(),o}let td=0;function RecoilRoot_INTERNAL({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:o,children:n}){let r;let getGraph=e=>{let t=r.current.graphsByVersion;if(t.has(e))return Recoil_nullthrows(t.get(e));let o=e5();return t.set(e,o),o},subscribeToTransactions=(e,t)=>{if(null==t){let{transactionSubscriptions:t}=l.current.getState(),o=td++;return t.set(o,e),{release:()=>{t.delete(o)}}}{let{nodeTransactionSubscriptions:o}=l.current.getState();o.has(t)||o.set(t,new Map);let n=td++;return Recoil_nullthrows(o.get(t)).set(n,e),{release:()=>{let e=o.get(t);e&&(e.delete(n),0===e.size&&o.delete(t))}}}},addTransactionMetadata=e=>{for(let t of(startNextTreeIfNeeded(l.current),Object.keys(e)))Recoil_nullthrows(l.current.getState().nextTree).transactionMetadata[t]=e[t]},replaceState=e=>{let t;startNextTreeIfNeeded(l.current);let o=Recoil_nullthrows(r.current.nextTree);try{ts=!0,t=e(o)}finally{ts=!1}t!==o&&(r.current.nextTree=t,e6().early&&notifyComponents(l.current,r.current,t),Recoil_nullthrows(a.current)())},a=ta(null),i=tt(e=>{a.current=e},[a]),l=Recoil_useRefInitOnce(()=>null!=o?o:{storeID:e4(),getState:()=>r.current,replaceState,getGraph,subscribeToTransactions,addTransactionMetadata});null!=o&&(l.current=o),r=Recoil_useRefInitOnce(()=>null!=e?initialStoreState_DEPRECATED(l.current,e):null!=t?initialStoreState(t):eJ());let u=tr(()=>null==e3?void 0:e3(r,()=>r.current.currentTree.version),[r]);return tn(()=>{let e=l.current;for(let t of new Set(e.getState().knownAtoms))e0(e,t,"get");return()=>{for(let t of e.getState().knownAtoms)eX(e,t)}},[l]),s.createElement(tu.Provider,{value:l},s.createElement(tc.Provider,{value:u},s.createElement(Batcher,{setNotifyBatcherOfChange:i}),n))}function useRecoilStoreID(){return useStoreRef().current.storeID}var tf={RecoilRoot:function(e){let{override:t,...o}=e,n=useStoreRef();return!1===t&&n.current!==tl?e.children:s.createElement(RecoilRoot_INTERNAL,o)},useStoreRef,useRecoilMutableSource:function(){let e=to(tc);return null==e&&expectationViolation_1("Attempted to use a Recoil hook outside of a <RecoilRoot>. <RecoilRoot> must be an ancestor of any component that uses Recoil hooks."),e},useRecoilStoreID,notifyComponents_FOR_TESTING:notifyComponents,sendEndOfBatchNotifications_FOR_TESTING:sendEndOfBatchNotifications},Recoil_shallowArrayEqual=function(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let o=0,n=e.length;o<n;o++)if(e[o]!==t[o])return!1;return!0};let{useEffect:th,useRef:tp}=s;var Recoil_usePrevious=function(e){let t=tp();return th(()=>{t.current=e}),t.current};let{useStoreRef:t_}=tf,{SUSPENSE_TIMEOUT_MS:ty}=em,{updateRetainCount:tm}=em,{RetentionZone:tS}=F,{useEffect:tR,useRef:tv}=s,{isSSR:tg}=eE;function useRetain_ACTUAL(e){let t=Array.isArray(e)?e:[e],o=t.map(e=>e instanceof tS?e:e.key),n=t_();tR(()=>{if(!p("recoil_memory_managament_2020"))return;let e=n.current;if(r.current&&!tg)window.clearTimeout(r.current),r.current=null;else for(let t of o)tm(e,t,1);return()=>{for(let t of o)tm(e,t,-1)}},[n,...o]);let r=tv(),a=Recoil_usePrevious(o);if(!tg&&(void 0===a||!Recoil_shallowArrayEqual(a,o))){let e=n.current;for(let t of o)tm(e,t,1);if(a)for(let t of a)tm(e,t,-1);r.current&&window.clearTimeout(r.current),r.current=window.setTimeout(()=>{for(let t of(r.current=null,o))tm(e,t,-1)},ty)}}var Recoil_useRetain=function(e){if(p("recoil_memory_managament_2020"))return useRetain_ACTUAL(e)},Recoil_useComponentName=function(){return"<component name not available>"};let{batchUpdates:tb}=eT,{DEFAULT_VALUE:tT}=N,{currentRendererSupportsUseSyncExternalStore:tA,reactMode:tw,useMutableSource:tE,useSyncExternalStore:tN}=R,{useRecoilMutableSource:tL,useStoreRef:tV}=tf,{isRecoilValue:tC}=g,{AbstractRecoilValue:tI,getRecoilValueAsLoadable:tk,setRecoilValue:tP,setUnvalidatedRecoilValue:tM,subscribeToRecoilValue:tU}=ed,{useCallback:tO,useEffect:tD,useMemo:tB,useRef:tx,useState:tF}=s,{setByAddingToSet:tz}=z,{isSSR:tW}=eE;function handleLoadable(e,t,o){if("hasValue"===e.state)return e.contents;if("loading"===e.state){let t=new Promise(t=>{let n=o.current.getState().suspendedComponentResolvers;n.add(t),tW&&Recoil_isPromise(e.contents)&&e.contents.finally(()=>{n.delete(t)})});throw t}if("hasError"===e.state)throw e.contents;throw err_1(`Invalid value of loadable atom "${t.key}"`)}function useRecoilInterface_DEPRECATED(){let e=Recoil_useComponentName(),t=tV(),[,o]=tF([]),n=tx(new Set);n.current=new Set;let r=tx(new Set),a=tx(new Map),i=tO(e=>{let t=a.current.get(e);t&&(t.release(),a.current.delete(e))},[a]),l=tO((e,t)=>{a.current.has(t)&&o([])},[]);return tD(()=>{let o=t.current;Recoil_differenceSets(n.current,r.current).forEach(t=>{if(a.current.has(t)){expectationViolation_1(`Double subscription to RecoilValue "${t}"`);return}let n=tU(o,new tI(t),e=>l(e,t),e);a.current.set(t,n);let r=o.getState();r.nextTree?o.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{l(o.getState(),t)}):l(o.getState(),t)}),Recoil_differenceSets(r.current,n.current).forEach(e=>{i(e)}),r.current=n.current}),tD(()=>{let o=a.current;return Recoil_differenceSets(n.current,new Set(o.keys())).forEach(n=>{let r=tU(t.current,new tI(n),e=>l(e,n),e);o.set(n,r)}),()=>o.forEach((e,t)=>i(t))},[e,t,i,l]),tB(()=>{function useSetRecoilState(e){return o=>{tP(t.current,e,o)}}function useRecoilValueLoadable(e){var o;n.current.has(e.key)||(n.current=tz(n.current,e.key));let r=t.current.getState();return tk(t.current,e,tw().early&&null!==(o=r.nextTree)&&void 0!==o?o:r.currentTree)}function useRecoilValue(e){let o=useRecoilValueLoadable(e);return handleLoadable(o,e,t)}function useRecoilState(e){return[useRecoilValue(e),useSetRecoilState(e)]}function useRecoilStateLoadable(e){return[useRecoilValueLoadable(e),useSetRecoilState(e)]}return{getRecoilValue:useRecoilValue,getRecoilValueLoadable:useRecoilValueLoadable,getRecoilState:useRecoilState,getRecoilStateLoadable:useRecoilStateLoadable,getSetRecoilState:useSetRecoilState,getResetRecoilState:function(e){return()=>tP(t.current,e,tT)}}},[n,t])}function useRecoilValueLoadable_SYNC_EXTERNAL_STORE(e){let t=tV(),o=Recoil_useComponentName(),n=tO(()=>{var o;let n=t.current,r=n.getState(),a=tw().early&&null!==(o=r.nextTree)&&void 0!==o?o:r.currentTree,i=tk(n,e,a);return{loadable:i,key:e.key}},[t,e]),r=tO(e=>{let t;return()=>{var o,n;let r=e();return null!==(o=t)&&void 0!==o&&o.loadable.is(r.loadable)&&(null===(n=t)||void 0===n?void 0:n.key)===r.key?t:(t=r,r)}},[]),a=tB(()=>r(n),[n,r]),i=tO(n=>{let r=t.current,a=tU(r,e,n,o);return a.release},[t,e,o]);return tN(i,a,a).loadable}function useRecoilValueLoadable_MUTABLE_SOURCE(e){let t=tV(),o=tO(()=>{var o;let n=t.current,r=n.getState(),a=tw().early&&null!==(o=r.nextTree)&&void 0!==o?o:r.currentTree;return tk(n,e,a)},[t,e]),n=tO(()=>o(),[o]),r=Recoil_useComponentName(),a=tO((n,a)=>{let i=t.current,l=tU(i,e,()=>{if(!p("recoil_suppress_rerender_in_callback"))return a();let e=o();s.current.is(e)||a(),s.current=e},r);return l.release},[t,e,r,o]),i=tL();if(null==i)throw err_1("Recoil hooks must be used in components contained within a <RecoilRoot> component.");let l=tE(i,n,a),s=tx(l);return tD(()=>{s.current=l}),l}function useRecoilValueLoadable_TRANSITION_SUPPORT(e){let t=tV(),o=Recoil_useComponentName(),n=tO(()=>{var o;let n=t.current,r=n.getState(),a=tw().early&&null!==(o=r.nextTree)&&void 0!==o?o:r.currentTree;return tk(n,e,a)},[t,e]),r=tO(()=>({loadable:n(),key:e.key}),[n,e.key]),a=tO(e=>{let t=r();return e.loadable.is(t.loadable)&&e.key===t.key?e:t},[r]);tD(()=>{let n=tU(t.current,e,e=>{l(a)},o);return l(a),n.release},[o,e,t,a]);let[i,l]=tF(r);return i.key!==e.key?r().loadable:i.loadable}function useRecoilValueLoadable_LEGACY(e){let t=tV(),[,o]=tF([]),n=Recoil_useComponentName(),r=tO(()=>{var o;let n=t.current,r=n.getState(),a=tw().early&&null!==(o=r.nextTree)&&void 0!==o?o:r.currentTree;return tk(n,e,a)},[t,e]),a=r(),i=tx(a);return tD(()=>{i.current=a}),tD(()=>{let a=t.current,l=a.getState(),s=tU(a,e,e=>{var t;if(!p("recoil_suppress_rerender_in_callback"))return o([]);let n=r();null!==(t=i.current)&&void 0!==t&&t.is(n)||o(n),i.current=n},n);if(l.nextTree)a.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{i.current=null,o([])});else{var u;if(!p("recoil_suppress_rerender_in_callback"))return o([]);let e=r();null!==(u=i.current)&&void 0!==u&&u.is(e)||o(e),i.current=e}return s.release},[n,r,e,t]),a}function useRecoilValueLoadable(e){return p("recoil_memory_managament_2020")&&Recoil_useRetain(e),({TRANSITION_SUPPORT:useRecoilValueLoadable_TRANSITION_SUPPORT,SYNC_EXTERNAL_STORE:tA()?useRecoilValueLoadable_SYNC_EXTERNAL_STORE:useRecoilValueLoadable_TRANSITION_SUPPORT,MUTABLE_SOURCE:useRecoilValueLoadable_MUTABLE_SOURCE,LEGACY:useRecoilValueLoadable_LEGACY})[tw().mode](e)}function useRecoilValue(e){let t=tV(),o=useRecoilValueLoadable(e);return handleLoadable(o,e,t)}function useSetRecoilState(e){let t=tV();return tO(o=>{tP(t.current,e,o)},[t,e])}function useResetRecoilState(e){let t=tV();return tO(()=>{tP(t.current,e,tT)},[t,e])}function useRecoilState(e){return[useRecoilValue(e),useSetRecoilState(e)]}function useRecoilStateLoadable(e){return[useRecoilValueLoadable(e),useSetRecoilState(e)]}function useSetUnvalidatedAtomValues(){let e=tV();return(t,o={})=>{tb(()=>{e.current.addTransactionMetadata(o),t.forEach((t,o)=>tM(e.current,new tI(o),t))})}}function useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(e){return p("recoil_memory_managament_2020")&&Recoil_useRetain(e),useRecoilValueLoadable_TRANSITION_SUPPORT(e)}function useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(e){let t=tV(),o=useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(e);return handleLoadable(o,e,t)}function useRecoilState_TRANSITION_SUPPORT_UNSTABLE(e){return[useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(e),useSetRecoilState(e)]}var Recoil_filterMap=function(e,t){let o=new Map;for(let[n,r]of e)t(r,n)&&o.set(n,r);return o},Recoil_filterSet=function(e,t){let o=new Set;for(let n of e)t(n)&&o.add(n);return o},Recoil_mergeMaps=function(...e){let t=new Map;for(let o=0;o<e.length;o++){let n;let r=e[o].keys();for(;!(n=r.next()).done;)t.set(n.value,e[o].get(n.value))}return t};let{batchUpdates:tG}=eT,{DEFAULT_VALUE:t$,getNode:tH,nodes:tK}=N,{useStoreRef:tq}=tf,{AbstractRecoilValue:tj,setRecoilValueLoadable:tZ}=ed,{SUSPENSE_TIMEOUT_MS:tY}=em,{cloneSnapshot:tJ}=ej,{useCallback:tX,useEffect:tQ,useRef:t0,useState:t1}=s,{isSSR:t2}=eE;function useTransactionSubscription(e){let t=tq();tQ(()=>{let o=t.current.subscribeToTransactions(e);return o.release},[e,t])}function externallyVisibleAtomValuesInState(e){let t=e.atomValues.toMap(),o=Recoil_mapMap(Recoil_filterMap(t,(e,t)=>{let o=tH(t),n=o.persistence_UNSTABLE;return null!=n&&"none"!==n.type&&"hasValue"===e.state}),e=>e.contents);return Recoil_mergeMaps(e.nonvalidatedAtoms.toMap(),o)}function gotoSnapshot(e,t){var o;let n=e.getState(),r=null!==(o=n.nextTree)&&void 0!==o?o:n.currentTree,a=t.getStore_INTERNAL().getState().currentTree;tG(()=>{let o=new Set;for(let e of[r.atomValues.keys(),a.atomValues.keys()])for(let t of e){var n,i;(null===(n=r.atomValues.get(t))||void 0===n?void 0:n.contents)!==(null===(i=a.atomValues.get(t))||void 0===i?void 0:i.contents)&&tH(t).shouldRestoreFromSnapshots&&o.add(t)}o.forEach(t=>{tZ(e,new tj(t),a.atomValues.has(t)?Recoil_nullthrows(a.atomValues.get(t)):t$)}),e.replaceState(e=>({...e,stateID:t.getID()}))})}function useGotoRecoilSnapshot(){let e=tq();return tX(t=>gotoSnapshot(e.current,t),[e])}var t5={useRecoilSnapshot:function(){let e=tq(),[t,o]=t1(()=>tJ(e.current)),n=Recoil_usePrevious(t),r=t0(),a=t0();if(useTransactionSubscription(tX(e=>o(tJ(e)),[])),tQ(()=>{let e=t.retain();if(r.current&&!t2){var o;window.clearTimeout(r.current),r.current=null,null===(o=a.current)||void 0===o||o.call(a),a.current=null}return()=>{window.setTimeout(e,10)}},[t]),n!==t&&!t2){if(r.current){var i;window.clearTimeout(r.current),r.current=null,null===(i=a.current)||void 0===i||i.call(a),a.current=null}a.current=t.retain(),r.current=window.setTimeout(()=>{var e;r.current=null,null===(e=a.current)||void 0===e||e.call(a),a.current=null},tY)}return t},gotoSnapshot,useGotoRecoilSnapshot,useRecoilTransactionObserver:function(e){useTransactionSubscription(tX(t=>{let o=tJ(t,"latest"),n=tJ(t,"previous");e({snapshot:o,previousSnapshot:n})},[e]))},useTransactionObservation_DEPRECATED:function(e){useTransactionSubscription(tX(t=>{let o=t.getState().previousTree,n=t.getState().currentTree;o||(recoverableViolation_1("Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil"),o=t.getState().currentTree);let r=externallyVisibleAtomValuesInState(n),a=externallyVisibleAtomValuesInState(o),i=Recoil_mapMap(tK,e=>{var t,o,n,r;return{persistence_UNSTABLE:{type:null!==(t=null===(o=e.persistence_UNSTABLE)||void 0===o?void 0:o.type)&&void 0!==t?t:"none",backButton:null!==(n=null===(r=e.persistence_UNSTABLE)||void 0===r?void 0:r.backButton)&&void 0!==n&&n}}}),l=Recoil_filterSet(n.dirtyAtoms,e=>r.has(e)||a.has(e));e({atomValues:r,previousAtomValues:a,atomInfo:i,modifiedAtoms:l,transactionMetadata:{...n.transactionMetadata}})},[e]))},useTransactionSubscription_DEPRECATED:useTransactionSubscription};let{peekNodeInfo:t8}=j,{useStoreRef:t4}=tf,{reactMode:t3}=R,{RecoilRoot:t6,useStoreRef:t9}=tf,{useMemo:t7}=s,{loadableWithValue:oe}=f,{initializeNode:ot}=j,{DEFAULT_VALUE:oo,getNode:on}=N,{copyTreeState:or,getRecoilValueAsLoadable:oa,invalidateDownstreams:oi,writeLoadableToTreeState:ol}=ed;function isAtom(e){return"atom"===on(e.key).nodeType}let TransactionInterfaceImpl=class TransactionInterfaceImpl{constructor(e,t){_defineProperty(this,"_store",void 0),_defineProperty(this,"_treeState",void 0),_defineProperty(this,"_changes",void 0),_defineProperty(this,"get",e=>{if(this._changes.has(e.key))return this._changes.get(e.key);if(!isAtom(e))throw err_1("Reading selectors within atomicUpdate is not supported");let t=oa(this._store,e,this._treeState);if("hasValue"===t.state)return t.contents;if("hasError"===t.state)throw t.contents;throw err_1(`Expected Recoil atom ${e.key} to have a value, but it is in a loading state.`)}),_defineProperty(this,"set",(e,t)=>{if(!isAtom(e))throw err_1("Setting selectors within atomicUpdate is not supported");if("function"==typeof t){let o=this.get(e);this._changes.set(e.key,t(o))}else ot(this._store,e.key,"set"),this._changes.set(e.key,t)}),_defineProperty(this,"reset",e=>{this.set(e,oo)}),this._store=e,this._treeState=t,this._changes=new Map}newTreeState_INTERNAL(){if(0===this._changes.size)return this._treeState;let e=or(this._treeState);for(let[t,o]of this._changes)ol(e,t,oe(o));return oi(this._store,e),e}};var os=Object.freeze({__proto__:null,atomicUpdater:function(e){return t=>{e.replaceState(o=>{let n=new TransactionInterfaceImpl(e,o);return t(n),n.newTreeState_INTERNAL()})}}}),invariant_1=function(e,t){if(!e)throw Error(t)};let{atomicUpdater:ou}=os,{batchUpdates:oc}=eT,{DEFAULT_VALUE:od}=N,{useStoreRef:of}=tf,{refreshRecoilValue:oh,setRecoilValue:op}=ed,{cloneSnapshot:o_}=ej,{gotoSnapshot:oy}=t5,{useCallback:om}=s;let Sentinel=class Sentinel{};let oS=new Sentinel;function recoilCallback(e,t,o,n){let r,a=oS;if(oc(()=>{let i="useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if("function"!=typeof t)throw err_1(i);let l=Recoil_lazyProxy({...null!=n?n:{},set:(t,o)=>op(e,t,o),reset:t=>op(e,t,od),refresh:t=>oh(e,t),gotoSnapshot:t=>oy(e,t),transact_UNSTABLE:t=>ou(e)(t)},{snapshot:()=>{let t=o_(e);return r=t.retain(),t}}),s=t(l);if("function"!=typeof s)throw err_1(i);a=s(...o)}),a instanceof Sentinel&&invariant_1(!1),Recoil_isPromise(a))a=a.finally(()=>{var e;null===(e=r)||void 0===e||e()});else{var i;null===(i=r)||void 0===i||i()}return a}function useRecoilCallback(e,t){let o=of();return om((...t)=>recoilCallback(o.current,e,t),null!=t?[...t,o]:void 0)}var oR={recoilCallback,useRecoilCallback};let{useStoreRef:ov}=tf,{refreshRecoilValue:og}=ed,{useCallback:ob}=s,{atomicUpdater:oT}=os,{useStoreRef:oA}=tf,{useMemo:ow}=s;let WrappedValue=class WrappedValue{constructor(e){_defineProperty(this,"value",void 0),this.value=e}};var oE=Object.freeze({__proto__:null,WrappedValue:{WrappedValue}.WrappedValue});let{isFastRefreshEnabled:oN}=R;let ChangedPathError=class ChangedPathError extends Error{};let TreeCache=class TreeCache{constructor(e){var t,o,n;_defineProperty(this,"_name",void 0),_defineProperty(this,"_numLeafs",void 0),_defineProperty(this,"_root",void 0),_defineProperty(this,"_onHit",void 0),_defineProperty(this,"_onSet",void 0),_defineProperty(this,"_mapNodeValue",void 0),this._name=null==e?void 0:e.name,this._numLeafs=0,this._root=null,this._onHit=null!==(t=null==e?void 0:e.onHit)&&void 0!==t?t:()=>{},this._onSet=null!==(o=null==e?void 0:e.onSet)&&void 0!==o?o:()=>{},this._mapNodeValue=null!==(n=null==e?void 0:e.mapNodeValue)&&void 0!==n?n:e=>e}size(){return this._numLeafs}root(){return this._root}get(e,t){var o;return null===(o=this.getLeafNode(e,t))||void 0===o?void 0:o.value}getLeafNode(e,t){if(null==this._root)return;let o=this._root;for(;o;){if(null==t||t.onNodeVisit(o),"leaf"===o.type)return this._onHit(o),o;let n=this._mapNodeValue(e(o.nodeKey));o=o.branches.get(n)}}set(e,t,o){let addLeaf=()=>{var n,r,a,i,l,s,u;let c,d;for(let[t,n]of e){let e=this._root;if((null==e?void 0:e.type)==="leaf")throw this.invalidCacheError();let r=c;if("branch"!==(c=null!==(l=c=r?r.branches.get(d):e)&&void 0!==l?l:{type:"branch",nodeKey:t,parent:r,branches:new Map,branchKey:d}).type||c.nodeKey!==t)throw this.invalidCacheError();null==r||r.branches.set(d,c),null==o||null===(s=o.onNodeVisit)||void 0===s||s.call(o,c),d=this._mapNodeValue(n),this._root=null!==(u=this._root)&&void 0!==u?u:c}let f=c?null===(n=c)||void 0===n?void 0:n.branches.get(d):this._root;if(null!=f&&("leaf"!==f.type||f.branchKey!==d))throw this.invalidCacheError();let h={type:"leaf",value:t,parent:c,branchKey:d};null===(r=c)||void 0===r||r.branches.set(d,h),this._root=null!==(a=this._root)&&void 0!==a?a:h,this._numLeafs++,this._onSet(h),null==o||null===(i=o.onNodeVisit)||void 0===i||i.call(o,h)};try{addLeaf()}catch(e){if(e instanceof ChangedPathError)this.clear(),addLeaf();else throw e}}delete(e){let t=this.root();if(!t)return!1;if(e===t)return this._root=null,this._numLeafs=0,!0;let o=e.parent,n=e.branchKey;for(;o;){var r;if(o.branches.delete(n),o===t)return 0===o.branches.size?(this._root=null,this._numLeafs=0):this._numLeafs--,!0;if(o.branches.size>0)break;n=null===(r=o)||void 0===r?void 0:r.branchKey,o=o.parent}for(;o!==t;o=o.parent)if(null==o)return!1;return this._numLeafs--,!0}clear(){this._numLeafs=0,this._root=null}invalidCacheError(){let e=oN()?"Possible Fast Refresh module reload detected.  This may also be caused by an selector returning inconsistent values. Resetting cache.":"Invalid cache values.  This happens when selectors do not return consistent values for the same input dependency values.  That may also be caused when using Fast Refresh to change a selector implementation.  Resetting cache.";throw recoverableViolation_1(e+(null!=this._name?` - ${this._name}`:"")),new ChangedPathError}};var oL=Object.freeze({__proto__:null,TreeCache:{TreeCache}.TreeCache});let LRUCache=class LRUCache{constructor(e){var t;_defineProperty(this,"_maxSize",void 0),_defineProperty(this,"_size",void 0),_defineProperty(this,"_head",void 0),_defineProperty(this,"_tail",void 0),_defineProperty(this,"_map",void 0),_defineProperty(this,"_keyMapper",void 0),this._maxSize=e.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=null!==(t=e.mapKey)&&void 0!==t?t:e=>e}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(e){return this._map.has(this._keyMapper(e))}get(e){let t=this._keyMapper(e),o=this._map.get(t);if(o)return this.set(e,o.value),o.value}set(e,t){let o=this._keyMapper(e),n=this._map.get(o);n&&this.delete(e);let r=this.head(),a={key:e,right:r,left:null,value:t};r?r.left=a:this._tail=a,this._map.set(o,a),this._head=a,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){let e=this.tail();e&&this.delete(e.key)}delete(e){let t=this._keyMapper(e);if(!this._size||!this._map.has(t))return;let o=Recoil_nullthrows(this._map.get(t)),n=o.right,r=o.left;n&&(n.left=o.left),r&&(r.right=o.right),o===this.head()&&(this._head=n),o===this.tail()&&(this._tail=r),this._map.delete(t),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}};var oV=Object.freeze({__proto__:null,LRUCache:{LRUCache}.LRUCache});let{LRUCache:oC}=oV,{TreeCache:oI}=oL;var Recoil_treeCacheLRU=function({name:e,maxSize:t,mapNodeValue:o=e=>e}){let n=new oC({maxSize:t}),r=new oI({name:e,mapNodeValue:o,onHit:e=>{n.set(e,!0)},onSet:e=>{let o=n.tail();n.set(e,!0),o&&r.size()>t&&r.delete(o.key)}});return r};function stringify(e,t,o){if("string"==typeof e&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if((null==t?void 0:t.allowFunctions)!==!0)throw err_1("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(null===e)return"null";if("object"!=typeof e){var n;return null!==(n=JSON.stringify(e))&&void 0!==n?n:""}if(Recoil_isPromise(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map((e,o)=>stringify(e,t,o.toString()))}]`;if("function"==typeof e.toJSON)return stringify(e.toJSON(o),t,o);if(e instanceof Map){let n={};for(let[o,r]of e)n["string"==typeof o?o:stringify(o,t)]=r;return stringify(n,t,o)}return e instanceof Set?stringify(Array.from(e).sort((e,o)=>stringify(e,t).localeCompare(stringify(o,t))),t,o):void 0!==Symbol&&null!=e[Symbol.iterator]&&"function"==typeof e[Symbol.iterator]?stringify(Array.from(e),t,o):`{${Object.keys(e).filter(t=>void 0!==e[t]).sort().map(o=>`${stringify(o,t)}:${stringify(e[o],t,o)}`).join(",")}}`}var Recoil_stableStringify=function(e,t={allowFunctions:!1}){return stringify(e,t)};let{TreeCache:ok}=oL,oP={equality:"reference",eviction:"keep-all",maxSize:1/0};function getValueMapper(e){switch(e){case"reference":return e=>e;case"value":return e=>Recoil_stableStringify(e)}throw err_1(`Unrecognized equality policy ${e}`)}function getTreeCache(e,t,o,n){switch(e){case"keep-all":return new ok({name:n,mapNodeValue:o});case"lru":return Recoil_treeCacheLRU({name:n,maxSize:Recoil_nullthrows(t),mapNodeValue:o});case"most-recent":return Recoil_treeCacheLRU({name:n,maxSize:1,mapNodeValue:o})}throw err_1(`Unrecognized eviction policy ${e}`)}var Recoil_treeCacheFromPolicy=function({equality:e=oP.equality,eviction:t=oP.eviction,maxSize:o=oP.maxSize}=oP,n){let r=getValueMapper(e);return getTreeCache(t,o,r,n)};let{isReactNative:oM,isWindow:oU}=eE;function startPerfBlock(e){return()=>null}let{isLoadable:oO,loadableWithError:oD,loadableWithPromise:oB,loadableWithValue:ox}=f,{WrappedValue:oF}=oE,{getNodeLoadable:oz,peekNodeLoadable:oW,setNodeValue:oG}=j,{saveDepsToStore:o$}=I,{DEFAULT_VALUE:oH,getConfigDeletionHandler:oK,getNode:oq,registerNode:oj}=N,{isRecoilValue:oZ}=g,{markRecoilValueModified:oY}=ed,{retainedByOptionWithDefault:oJ}=em,{recoilCallback:oX}=oR,{startPerfBlock:oQ}={startPerfBlock};let Canceled=class Canceled{};let o0=new Canceled,o1=[],o2=new Map,o5=(n=0,()=>n++);function selector(e){let t=null,{key:o,get:n,cachePolicy_UNSTABLE:r}=e,a=null!=e.set?e.set:void 0,i=new Set,l=Recoil_treeCacheFromPolicy(null!=r?r:{equality:"reference",eviction:"keep-all"},o),s=oJ(e.retainedBy_UNSTABLE),u=new Map,c=0;function selectorIsLive(){return!p("recoil_memory_managament_2020")||c>0}function selectorInit(e){return e.getState().knownSelectors.add(o),c++,()=>{c--}}function selectorShouldDeleteConfigOnRelease(){return void 0!==oK(o)&&!selectorIsLive()}function notifyStoresOfResolvedAsync(e,t){isLatestExecution(e,t)&&clearExecutionInfo(e),notifyWaitingStores(t,!0)}function notifyStoresOfNewAsyncDep(e,t){if(isLatestExecution(e,t)){let o=Recoil_nullthrows(getExecutionInfo(e));o.stateVersions.clear(),notifyWaitingStores(t,!1)}}function notifyWaitingStores(e,o){let n=o2.get(e);if(null!=n){for(let e of n)oY(e,Recoil_nullthrows(t));o&&o2.delete(e)}}function markStoreWaitingForResolvedAsync(e,t){let o=o2.get(t);null==o&&o2.set(t,o=new Set),o.add(e)}function wrapResultPromise(e,t,o,n,r,a){return t.then(t=>{if(!selectorIsLive())throw clearExecutionInfo(e),o0;let a=ox(t);return setCache(o,a,n),notifyStoresOfResolvedAsync(e,r),t}).catch(t=>{if(!selectorIsLive())throw clearExecutionInfo(e),o0;if(Recoil_isPromise(t))return wrapPendingDependencyPromise(e,t,o,n,r,a);let i=oD(t);throw setCache(o,i,n),notifyStoresOfResolvedAsync(e,r),t})}function wrapPendingDependencyPromise(e,t,o,n,r,a){return t.then(n=>{if(!selectorIsLive())throw clearExecutionInfo(e),o0;null!=a.loadingDepKey&&a.loadingDepPromise===t?o.atomValues.set(a.loadingDepKey,ox(n)):e.getState().knownSelectors.forEach(e=>{o.atomValues.delete(e)});let i=getLoadableFromCacheAndUpdateDeps(e,o);if(i&&"loading"!==i.state){if((isLatestExecution(e,r)||null==getExecutionInfo(e))&&notifyStoresOfResolvedAsync(e,r),"hasValue"===i.state)return i.contents;throw i.contents}if(!isLatestExecution(e,r)){let t=getInProgressExecutionInfo(e,o);if(null!=t)return t.loadingLoadable.contents}let[l,s]=evaluateSelectorGetter(e,o,r);if("loading"!==l.state&&(setCache(o,l,s),notifyStoresOfResolvedAsync(e,r)),"hasError"===l.state)throw l.contents;return l.contents}).catch(t=>{if(t instanceof Canceled)throw o0;if(!selectorIsLive())throw clearExecutionInfo(e),o0;let a=oD(t);throw setCache(o,a,n),notifyStoresOfResolvedAsync(e,r),t})}function updateDeps(e,t,n,r){var a,l,s,u,c,d,f;for(let h of((isLatestExecution(e,r)||t.version===(null===(a=e.getState())||void 0===a?void 0:null===(l=a.currentTree)||void 0===l?void 0:l.version)||t.version===(null===(s=e.getState())||void 0===s?void 0:null===(u=s.nextTree)||void 0===u?void 0:u.version))&&o$(o,n,e,null!==(c=null===(d=e.getState())||void 0===d?void 0:null===(f=d.nextTree)||void 0===f?void 0:f.version)&&void 0!==c?c:e.getState().currentTree.version),n))i.add(h)}function evaluateSelectorGetter(e,r,a){let i,l;let s=oQ(o),u=!0,c=!0,finishEvaluation=()=>{s(),c=!1},d=!1,f={loadingDepKey:null,loadingDepPromise:null},h=new Map;function getRecoilValue({key:t}){let o=oz(e,r,t);switch(h.set(t,o),u||(updateDeps(e,r,new Set(h.keys()),a),notifyStoresOfNewAsyncDep(e,a)),o.state){case"hasValue":return o.contents;case"hasError":throw o.contents;case"loading":throw f.loadingDepKey=t,f.loadingDepPromise=o.contents,o.contents}throw err_1("Invalid Loadable state")}try{i=n({get:getRecoilValue,getCallback:o=>(...n)=>{if(c)throw err_1("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");return null!=t||invariant_1(!1),oX(e,o,n,{node:t})}}),i=oZ(i)?getRecoilValue(i):i,oO(i)&&("hasError"===i.state&&(d=!0),i=i.contents),Recoil_isPromise(i)?i=wrapResultPromise(e,i,r,h,a,f).finally(finishEvaluation):finishEvaluation(),i=i instanceof oF?i.value:i}catch(t){Recoil_isPromise(i=t)?i=wrapPendingDependencyPromise(e,i,r,h,a,f).finally(finishEvaluation):(d=!0,finishEvaluation())}return l=d?oD(i):Recoil_isPromise(i)?oB(i):ox(i),u=!1,updateExecutionInfoDepValues(e,a,h),updateDeps(e,r,new Set(h.keys()),a),[l,h]}function getLoadableFromCacheAndUpdateDeps(e,t){let n=t.atomValues.get(o);if(null!=n)return n;let r=new Set;try{n=l.get(o=>("string"!=typeof o&&invariant_1(!1),oz(e,t,o).contents),{onNodeVisit:e=>{"branch"===e.type&&e.nodeKey!==o&&r.add(e.nodeKey)}})}catch(e){throw err_1(`Problem with cache lookup for selector "${o}": ${e.message}`)}if(n){var a;t.atomValues.set(o,n),updateDeps(e,t,r,null===(a=getExecutionInfo(e))||void 0===a?void 0:a.executionID)}return n}function getSelectorLoadableAndUpdateDeps(e,t){let o=getLoadableFromCacheAndUpdateDeps(e,t);if(null!=o)return clearExecutionInfo(e),o;let n=getInProgressExecutionInfo(e,t);if(null!=n){var r;return(null===(r=n.loadingLoadable)||void 0===r?void 0:r.state)==="loading"&&markStoreWaitingForResolvedAsync(e,n.executionID),n.loadingLoadable}let a=o5(),[i,l]=evaluateSelectorGetter(e,t,a);return"loading"===i.state?(setExecutionInfo(e,a,i,l,t),markStoreWaitingForResolvedAsync(e,a)):(clearExecutionInfo(e),setCache(t,i,l)),i}function getInProgressExecutionInfo(e,t){let o=Recoil_concatIterables([u.has(e)?[Recoil_nullthrows(u.get(e))]:[],Recoil_mapIterable(Recoil_filterIterable(u,([t])=>t!==e),([,e])=>e)]);function anyDepChanged(o){for(let[n,r]of o)if(!oz(e,t,n).is(r))return!0;return!1}for(let e of o){if(e.stateVersions.get(t.version)||!anyDepChanged(e.depValuesDiscoveredSoFarDuringAsyncWork))return e.stateVersions.set(t.version,!0),e;e.stateVersions.set(t.version,!1)}}function getExecutionInfo(e){return u.get(e)}function setExecutionInfo(e,t,o,n,r){u.set(e,{depValuesDiscoveredSoFarDuringAsyncWork:n,executionID:t,loadingLoadable:o,stateVersions:new Map([[r.version,!0]])})}function updateExecutionInfoDepValues(e,t,o){if(isLatestExecution(e,t)){let t=getExecutionInfo(e);null!=t&&(t.depValuesDiscoveredSoFarDuringAsyncWork=o)}}function clearExecutionInfo(e){u.delete(e)}function isLatestExecution(e,t){var o;return t===(null===(o=getExecutionInfo(e))||void 0===o?void 0:o.executionID)}function depValuesToDepRoute(e){return Array.from(e.entries()).map(([e,t])=>[e,t.contents])}function setCache(e,t,n){e.atomValues.set(o,t);try{l.set(depValuesToDepRoute(n),t)}catch(e){throw err_1(`Problem with setting cache for selector "${o}": ${e.message}`)}}function detectCircularDependencies(e){if(o1.includes(o)){let e=`Recoil selector has circular dependencies: ${o1.slice(o1.indexOf(o)).join(" → ")}`;return oD(err_1(e))}o1.push(o);try{return e()}finally{o1.pop()}}function selectorPeek(e,t){let n=t.atomValues.get(o);return null!=n?n:l.get(o=>{var n;return"string"!=typeof o&&invariant_1(!1),null===(n=oW(e,t,o))||void 0===n?void 0:n.contents})}function selectorGet(e,t){return detectCircularDependencies(()=>getSelectorLoadableAndUpdateDeps(e,t))}function invalidateSelector(e){e.atomValues.delete(o)}function clearSelectorCache(e,o){for(let r of(null!=t||invariant_1(!1),i)){var n;let t=oq(r);null===(n=t.clearCache)||void 0===n||n.call(t,e,o)}i.clear(),invalidateSelector(o),l.clear(),oY(e,t)}return t=null!=a?oj({key:o,nodeType:"selector",peek:selectorPeek,get:selectorGet,set:(e,t,n)=>{let r=!1,i=new Map;function getRecoilValue({key:n}){if(r)throw err_1("Recoil: Async selector sets are not currently supported.");let a=oz(e,t,n);if("hasValue"===a.state)return a.contents;if("loading"===a.state){let e=`Getting value of asynchronous atom or selector "${n}" in a pending state while setting selector "${o}" is not yet supported.`;throw recoverableViolation_1(e),err_1(e)}throw a.contents}function setRecoilState(o,n){if(r){let e="Recoil: Async selector sets are not currently supported.";throw recoverableViolation_1(e),err_1(e)}let a="function"==typeof n?n(getRecoilValue(o)):n,l=oG(e,t,o.key,a);l.forEach((e,t)=>i.set(t,e))}function resetRecoilState(e){setRecoilState(e,oH)}let l=a({set:setRecoilState,get:getRecoilValue,reset:resetRecoilState},n);if(void 0!==l)throw err_1(Recoil_isPromise(l)?"Recoil: Async selector sets are not currently supported.":"Recoil: selector set should be a void function.");return r=!0,i},init:selectorInit,invalidate:invalidateSelector,clearCache:clearSelectorCache,shouldDeleteConfigOnRelease:selectorShouldDeleteConfigOnRelease,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:s}):oj({key:o,nodeType:"selector",peek:selectorPeek,get:selectorGet,init:selectorInit,invalidate:invalidateSelector,clearCache:clearSelectorCache,shouldDeleteConfigOnRelease:selectorShouldDeleteConfigOnRelease,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:s})}selector.value=e=>new oF(e);var o8=selector;let{isLoadable:o4,loadableWithError:o3,loadableWithPromise:o6,loadableWithValue:o9}=f,{WrappedValue:o7}=oE,{peekNodeInfo:ne}=j,{DEFAULT_VALUE:nt,DefaultValue:no,getConfigDeletionHandler:nn,registerNode:nr,setConfigDeletionHandler:na}=N,{isRecoilValue:ni}=g,{getRecoilValueAsLoadable:nl,markRecoilValueModified:ns,setRecoilValue:nu,setRecoilValueLoadable:nc}=ed,{retainedByOptionWithDefault:nd}=em,unwrap=e=>e instanceof o7?e.value:e;function baseAtom(e){var t;let o;let{key:n,persistence_UNSTABLE:r}=e,a=nd(e.retainedBy_UNSTABLE),i=0;function unwrapPromise(e){return o6(e.then(e=>(l=o9(e),e)).catch(e=>{throw l=o3(e),e}))}let l=Recoil_isPromise(e.default)?unwrapPromise(e.default):o4(e.default)?"loading"===e.default.state?unwrapPromise(e.default.contents):e.default:o9(unwrap(e.default));l.contents;let s=new Map;function wrapPendingPromise(e,t){let o=t.then(t=>{var r,a;let i=null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree;return(null===(a=i.atomValues.get(n))||void 0===a?void 0:a.contents)===o&&nu(e,u,t),t}).catch(t=>{var r,a;let i=null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree;throw(null===(a=i.atomValues.get(n))||void 0===a?void 0:a.contents)===o&&nc(e,u,o3(t)),t});return o}function initAtom(t,o,r){var a,c,d;i++,t.getState().knownAtoms.add(n),"loading"===l.state&&l.contents.finally(()=>{var e;let o=null!==(e=t.getState().nextTree)&&void 0!==e?e:t.getState().currentTree;o.atomValues.has(n)||ns(t,u)});let f=null!==(a=e.effects)&&void 0!==a?a:e.effects_UNSTABLE;if(null!=f){let e=nt,a=!0,i=!1,h=null;function getLoadable(r){if(a&&r.key===n){let n=e;return n instanceof no?peekAtom(t,o):Recoil_isPromise(n)?o6(n.then(e=>e instanceof no?l.toPromise():e)):o9(n)}return nl(t,r)}function getPromise(e){return getLoadable(e).toPromise()}function getInfo_UNSTABLE(o){var r;let i=ne(t,null!==(r=t.getState().nextTree)&&void 0!==r?r:t.getState().currentTree,o.key);return!a||o.key!==n||e instanceof no?i:{...i,isSet:!0,loadable:getLoadable(o)}}let setSelf=o=>n=>{if(a){let t=getLoadable(u),r="hasValue"===t.state?t.contents:nt;Recoil_isPromise(e="function"==typeof n?n(r):n)&&(e=e.then(e=>(h={effect:o,value:e},e)))}else{if(Recoil_isPromise(n))throw err_1("Setting atoms to async values is not implemented.");"function"!=typeof n&&(h={effect:o,value:unwrap(n)}),nu(t,u,"function"==typeof n?e=>{let t=unwrap(n(e));return h={effect:o,value:t},t}:unwrap(n))}},resetSelf=e=>()=>setSelf(e)(nt),onSet=e=>o=>{var r;let{release:a}=t.subscribeToTransactions(t=>{var r,a,i,s,u;let{currentTree:c,previousTree:d}=t.getState();d||(recoverableViolation_1("Transaction subscribers notified without a next tree being present -- this is a bug in Recoil"),d=c);let f=null!==(r=c.atomValues.get(n))&&void 0!==r?r:l;if("hasValue"===f.state){let t=f.contents,r=null!==(a=d.atomValues.get(n))&&void 0!==a?a:l,p="hasValue"===r.state?r.contents:nt;(null===(i=h)||void 0===i?void 0:i.effect)!==e||(null===(s=h)||void 0===s?void 0:s.value)!==t?o(t,p,!c.atomValues.has(n)):(null===(u=h)||void 0===u?void 0:u.effect)===e&&(h=null)}},n);s.set(t,[...null!==(r=s.get(t))&&void 0!==r?r:[],a])};for(let o of f)try{let e=o({node:u,storeID:t.storeID,parentStoreID_UNSTABLE:t.parentStoreID,trigger:r,setSelf:setSelf(o),resetSelf:resetSelf(o),onSet:onSet(o),getPromise,getLoadable,getInfo_UNSTABLE});null!=e&&s.set(t,[...null!==(c=s.get(t))&&void 0!==c?c:[],e])}catch(t){e=t,i=!0}if(a=!1,!(e instanceof no)){let r=i?o3(e):Recoil_isPromise(e)?o6(wrapPendingPromise(t,e)):o9(unwrap(e));r.contents,o.atomValues.set(n,r),null===(d=t.getState().nextTree)||void 0===d||d.atomValues.set(n,r)}}return()=>{var e;i--,null===(e=s.get(t))||void 0===e||e.forEach(e=>e()),s.delete(t)}}function peekAtom(e,t){var r,a;return null!==(r=null!==(a=t.atomValues.get(n))&&void 0!==a?a:o)&&void 0!==r?r:l}function getAtom(e,t){if(t.atomValues.has(n))return Recoil_nullthrows(t.atomValues.get(n));if(!t.nonvalidatedAtoms.has(n))return l;{if(null!=o)return o;if(null==r)return expectationViolation_1(`Tried to restore a persisted value for atom ${n} but it has no persistence settings.`),l;let e=t.nonvalidatedAtoms.get(n),a=r.validator(e,nt),i=a instanceof no?l:o9(a);return o=i}}function invalidateAtom(){o=void 0}function setAtom(e,t,r){if(t.atomValues.has(n)){let e=Recoil_nullthrows(t.atomValues.get(n));if("hasValue"===e.state&&r===e.contents)return new Map}else if(!t.nonvalidatedAtoms.has(n)&&r instanceof no)return new Map;return o=void 0,new Map().set(n,o9(r))}function shouldDeleteConfigOnReleaseAtom(){return void 0!==nn(n)&&i<=0}let u=nr({key:n,nodeType:"atom",peek:peekAtom,get:getAtom,set:setAtom,init:initAtom,invalidate:invalidateAtom,shouldDeleteConfigOnRelease:shouldDeleteConfigOnReleaseAtom,dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:a});return u}function atom(e){let{...t}=e,o="default"in e?e.default:new Promise(()=>{});return ni(o)?atomWithFallback({...t,default:o}):baseAtom({...t,default:o})}function atomWithFallback(e){let t=atom({...e,default:nt,persistence_UNSTABLE:void 0===e.persistence_UNSTABLE?void 0:{...e.persistence_UNSTABLE,validator:t=>t instanceof no?t:Recoil_nullthrows(e.persistence_UNSTABLE).validator(t,nt)},effects:e.effects,effects_UNSTABLE:e.effects_UNSTABLE}),o=o8({key:`${e.key}__withFallback`,get:({get:o})=>{let n=o(t);return n instanceof no?e.default:n},set:({set:e},o)=>e(t,o),cachePolicy_UNSTABLE:{eviction:"most-recent"},dangerouslyAllowMutability:e.dangerouslyAllowMutability});return na(o.key,nn(e.key)),o}atom.value=e=>new o7(e);var nf=atom;let MapCache=class MapCache{constructor(e){var t;_defineProperty(this,"_map",void 0),_defineProperty(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=null!==(t=null==e?void 0:e.mapKey)&&void 0!==t?t:e=>e}size(){return this._map.size}has(e){return this._map.has(this._keyMapper(e))}get(e){return this._map.get(this._keyMapper(e))}set(e,t){this._map.set(this._keyMapper(e),t)}delete(e){this._map.delete(this._keyMapper(e))}clear(){this._map.clear()}};var nh=Object.freeze({__proto__:null,MapCache:{MapCache}.MapCache});let{LRUCache:np}=oV,{MapCache:n_}=nh,ny={equality:"reference",eviction:"none",maxSize:1/0};function getValueMapper$1(e){switch(e){case"reference":return e=>e;case"value":return e=>Recoil_stableStringify(e)}throw err_1(`Unrecognized equality policy ${e}`)}function getCache(e,t,o){switch(e){case"keep-all":return new n_({mapKey:o});case"lru":return new np({mapKey:o,maxSize:Recoil_nullthrows(t)});case"most-recent":return new np({mapKey:o,maxSize:1})}throw err_1(`Unrecognized eviction policy ${e}`)}var Recoil_cacheFromPolicy=function({equality:e=ny.equality,eviction:t=ny.eviction,maxSize:o=ny.maxSize}=ny){let n=getValueMapper$1(e),r=getCache(t,o,n);return r};let{setConfigDeletionHandler:nm}=N,{setConfigDeletionHandler:nS}=N,nR=0;var Recoil_selectorFamily=function(e){var t,o;let n=Recoil_cacheFromPolicy({equality:null!==(t=null===(o=e.cachePolicyForParams_UNSTABLE)||void 0===o?void 0:o.equality)&&void 0!==t?t:"value",eviction:"keep-all"});return t=>{var o;let r,a;try{r=n.get(t)}catch(t){throw err_1(`Problem with cache lookup for selector ${e.key}: ${t.message}`)}if(null!=r)return r;let i=`${e.key}__selectorFamily/${null!==(o=Recoil_stableStringify(t,{allowFunctions:!0}))&&void 0!==o?o:"void"}/${nR++}`,myGet=o=>e.get(t)(o),l=e.cachePolicy_UNSTABLE,s="function"==typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE;if(null!=e.set){let o=e.set;a=o8({key:i,get:myGet,set:(e,n)=>o(t)(e,n),cachePolicy_UNSTABLE:l,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:s})}else a=o8({key:i,get:myGet,cachePolicy_UNSTABLE:l,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:s});return n.set(t,a),nS(a.key,()=>{n.delete(t)}),a}};let nv=Recoil_selectorFamily({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}}),ng=Recoil_selectorFamily({key:"__error",get:e=>()=>{throw err_1(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}}),{loadableWithError:nb,loadableWithPromise:nT,loadableWithValue:nA}=f;function concurrentRequests(e,t){let o=Array(t.length).fill(void 0),n=Array(t.length).fill(void 0);for(let[r,a]of t.entries())try{o[r]=e(a)}catch(e){n[r]=e}return[o,n]}function isError(e){return null!=e&&!Recoil_isPromise(e)}function unwrapDependencies(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t])}function wrapResults(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce((e,o,n)=>({...e,[o]:t[n]}),{})}function wrapLoadables(e,t,o){let n=o.map((e,o)=>null==e?nA(t[o]):Recoil_isPromise(e)?nT(e):nb(e));return wrapResults(e,n)}function combineAsyncResultsWithSyncResults(e,t){return t.map((t,o)=>void 0===t?e[o]:t)}let nw=Recoil_selectorFamily({key:"__waitForNone",get:e=>({get:t})=>{let o=unwrapDependencies(e),[n,r]=concurrentRequests(t,o);return wrapLoadables(e,n,r)},dangerouslyAllowMutability:!0}),nE=Recoil_selectorFamily({key:"__waitForAny",get:e=>({get:t})=>{let o=unwrapDependencies(e),[n,r]=concurrentRequests(t,o);return r.some(e=>!Recoil_isPromise(e))?wrapLoadables(e,n,r):new Promise(t=>{for(let[o,a]of r.entries())Recoil_isPromise(a)&&a.then(a=>{n[o]=a,r[o]=void 0,t(wrapLoadables(e,n,r))}).catch(a=>{r[o]=a,t(wrapLoadables(e,n,r))})})},dangerouslyAllowMutability:!0}),nN=Recoil_selectorFamily({key:"__waitForAll",get:e=>({get:t})=>{let o=unwrapDependencies(e),[n,r]=concurrentRequests(t,o);if(r.every(e=>null==e))return wrapResults(e,n);let a=r.find(isError);if(null!=a)throw a;return Promise.all(r).then(t=>wrapResults(e,combineAsyncResultsWithSyncResults(n,t)))},dangerouslyAllowMutability:!0}),nL=Recoil_selectorFamily({key:"__waitForAllSettled",get:e=>({get:t})=>{let o=unwrapDependencies(e),[n,r]=concurrentRequests(t,o);return r.every(e=>!Recoil_isPromise(e))?wrapLoadables(e,n,r):Promise.all(r.map((e,t)=>Recoil_isPromise(e)?e.then(e=>{n[t]=e,r[t]=void 0}).catch(e=>{n[t]=void 0,r[t]=e}):null)).then(()=>wrapLoadables(e,n,r))},dangerouslyAllowMutability:!0}),nV=Recoil_selectorFamily({key:"__noWait",get:e=>({get:t})=>{try{return o8.value(nA(t(e)))}catch(e){return o8.value(Recoil_isPromise(e)?nT(e):nb(e))}},dangerouslyAllowMutability:!0}),{RecoilLoadable:nC}=f,{DefaultValue:nI}=N,{RecoilRoot:nk,useRecoilStoreID:nP}=tf,{isRecoilValue:nM}=g,{retentionZone:nU}=F,{freshSnapshot:nO}=ej,{useRecoilState:nD,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:nB,useRecoilStateLoadable:nx,useRecoilValue:nF,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:nz,useRecoilValueLoadable:nW,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:nG,useResetRecoilState:n$,useSetRecoilState:nH}={recoilComponentGetRecoilValueCount_FOR_TESTING:{current:0},useRecoilInterface:useRecoilInterface_DEPRECATED,useRecoilState,useRecoilStateLoadable,useRecoilValue,useRecoilValueLoadable,useResetRecoilState,useSetRecoilState,useSetUnvalidatedAtomValues,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,useRecoilState_TRANSITION_SUPPORT_UNSTABLE},{useGotoRecoilSnapshot:nK,useRecoilSnapshot:nq,useRecoilTransactionObserver:nj}=t5,{useRecoilCallback:nZ}=oR,{noWait:nY,waitForAll:nJ,waitForAllSettled:nX,waitForAny:nQ,waitForNone:n0}={waitForNone:nw,waitForAny:nE,waitForAll:nN,waitForAllSettled:nL,noWait:nV};var n1={DefaultValue:nI,isRecoilValue:nM,RecoilLoadable:nC,RecoilEnv:h,RecoilRoot:nk,useRecoilStoreID:nP,useRecoilBridgeAcrossReactRoots_UNSTABLE:function(){"MUTABLE_SOURCE"===t3().mode&&console.warn("Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.");let e=t9().current;return t7(()=>function({children:t}){return s.createElement(t6,{store_INTERNAL:e},t)},[e])},atom:nf,selector:o8,atomFamily:function(e){var t,o;let n=Recoil_cacheFromPolicy({equality:null!==(t=null===(o=e.cachePolicyForParams_UNSTABLE)||void 0===o?void 0:o.equality)&&void 0!==t?t:"value",eviction:"keep-all"});return t=>{var o,r;let a=n.get(t);if(null!=a)return a;let{cachePolicyForParams_UNSTABLE:i,...l}=e,s="default"in e?e.default:new Promise(()=>{}),u=nf({...l,key:`${e.key}__${null!==(o=Recoil_stableStringify(t))&&void 0!==o?o:"void"}`,default:"function"==typeof s?s(t):s,retainedBy_UNSTABLE:"function"==typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE,effects:"function"==typeof e.effects?e.effects(t):"function"==typeof e.effects_UNSTABLE?e.effects_UNSTABLE(t):null!==(r=e.effects)&&void 0!==r?r:e.effects_UNSTABLE});return n.set(t,u),nm(u.key,()=>{n.delete(t)}),u}},selectorFamily:Recoil_selectorFamily,constSelector:function(e){return nv(e)},errorSelector:function(e){return ng(e)},readOnlySelector:function(e){return e},noWait:nY,waitForNone:n0,waitForAny:nQ,waitForAll:nJ,waitForAllSettled:nX,useRecoilValue:nF,useRecoilValueLoadable:nW,useRecoilState:nD,useRecoilStateLoadable:nx,useSetRecoilState:nH,useResetRecoilState:n$,useGetRecoilValueInfo_UNSTABLE:function(){let e=t4();return({key:t})=>t8(e.current,e.current.getState().currentTree,t)},useRecoilRefresher_UNSTABLE:function(e){let t=ov();return ob(()=>{let o=t.current;og(o,e)},[e,t])},useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:nG,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:nz,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:nB,useRecoilCallback:nZ,useRecoilTransaction_UNSTABLE:function(e,t){let o=oA();return ow(()=>(...t)=>{let n=oT(o.current);n(o=>{e(o)(...t)})},null!=t?[...t,o]:void 0)},useGotoRecoilSnapshot:nK,useRecoilSnapshot:nq,useRecoilTransactionObserver_UNSTABLE:nj,snapshot_UNSTABLE:nO,useRetain:Recoil_useRetain,retentionZone:nU};n1.DefaultValue,n1.isRecoilValue,n1.RecoilLoadable,n1.RecoilEnv;var n2=n1.RecoilRoot;n1.useRecoilStoreID,n1.useRecoilBridgeAcrossReactRoots_UNSTABLE;var n5=n1.atom,n8=n1.selector;n1.atomFamily,n1.selectorFamily,n1.constSelector,n1.errorSelector,n1.readOnlySelector,n1.noWait,n1.waitForNone,n1.waitForAny,n1.waitForAll,n1.waitForAllSettled;var n4=n1.useRecoilValue;n1.useRecoilValueLoadable;var n3=n1.useRecoilState;n1.useRecoilStateLoadable;var n6=n1.useSetRecoilState;n1.useResetRecoilState,n1.useGetRecoilValueInfo_UNSTABLE,n1.useRecoilRefresher_UNSTABLE,n1.useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,n1.useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,n1.useRecoilState_TRANSITION_SUPPORT_UNSTABLE,n1.useRecoilCallback,n1.useRecoilTransaction_UNSTABLE,n1.useGotoRecoilSnapshot,n1.useRecoilSnapshot,n1.useRecoilTransactionObserver_UNSTABLE,n1.snapshot_UNSTABLE,n1.useRetain,n1.retentionZone}}]);